# -*- coding:utf-8 -*-
#+title:软件调试实战读书笔记
#+author:刘尚亮
#+email:phenix3443@gmail.com

* 第一章 谁编写软件，谁制造bug

  我们需要系统性的学习和实践调试方法。

* 第二章 系统性调试方法

  构建和测试过程中有调试机会：
  1. 可调试的代码:
  2. 插装：
  3. 宏定义：
  4. 编译器标志：
  5. 静态检查器：
  6. 选择的库：
  7. 链接器工具：
  8. 代码插装工具：
  9. 测试用例/输入数据：
  10. 调试器

* 第三章 查找根源-源码调试器

  如何系统的学习使用源码调试器：

  1. 运行程序（run,start）
  2. 栈跟踪（bt，backtrace，where,up,down）
  3. 断点（行，函数，条件，事件，观察点，捕获信号，捕获异常）
  4. 程序导航（pause，continue，next,step-in,step-out,step-over）
  5. 检查数据（print，display）

* 第四章 修复内存问题

  常见的内存访问错误：

  1. 内存泄漏：例如，忘记执行free或delete。
  2. 内存管理错误使用：例如，重复释放，释放未分配的内存，内存释放后继续使用等。
  3. 缓冲区溢出：例如，读写越界等。
  4. 使用未初始化的内存。

  调试工具：

  1. Purify
	 + 使用purify_stop_here()函数在检测到错误时候调用gdb调试器。
  2. Valgrind
	 + 只能捕获动态分配的内存越界错误。
	 + 使用--db-attach选项在检测到错误时候调用gdb调试器。
  3. Insure++
	 + 使用_Insure_trap_error()函数在检测到错误时候调用gdb调试器。

  内存调试器和源码调试器结合使用，定位出错位置。

  高效使用排查工具：
  1. 使用内存调试器的排查规则
  2. 不要自动排查所有与第三方库有关的错误。

  测试用例应该有很好的代码覆盖率。

* 第五章 剖析内存的使用

  内存剖析的步骤：
  1. 检查是否有大的内存泄漏。
  2. 估计预期的内存使用。
  3. 用多个输入来测量内存使用随时间的变化。
	 + top：观察rss
	 + Valgrind：Massif工具
  4. 查找使用内存的数据结构。
	 + Valgrind：Massif工具

* 第六章 解决性能问题

  1. 程序执行时间。
  2. 工具：gprof，Quantify，Callgrind，VTune

* 第七章 调试并行程序
  为什么并行会出问题：
  1. 对公共资源的访问。
  2. 语言代码对应机器指令不是原子执行。
  3. 异步事件和中断处理程序。

  并行程序常见问题：
  1. 竞争条件
	 + 使用GDB调试机器代码：disassemble，stepi
	 + 使用带有时钟信息的日志。
  2. 死锁
	+ info stack， info thread

  工具：
  + Helgrind


* 第八章 查找环境和编译器问题
** 环境问题
   1. 环境变量
   2. 本地安装依赖
   3. 当前工作目录依赖
   4. 进程ID依赖

   查看进程状态的命令：top，ps，/proc/<pid>，strace，ltrace

** 编译器bug

* 第九章 处理链接问题
  1. 解析未定义的符号：
	 + nm打印符号列表，
	 + C++符号反改编（demangle）：分析实用工具或C++filt
* 第十章 高级调试

* 第十一章 编写可调试的代码
** 注释
   函数注释要点：
   + 函数要做什么。
   + 说明函数参数，以及在如何处理异常参数。
   + 接口使用假设，比如是否必须在init函数之后使用。
   + 内存分配，例如返回的指针由谁释放。
   + 副作用。
   + 记录所有已知的陷进和临时折中办法。

** 编码风格
   + 不要压缩代码。
   + 为复杂表达式使用临时变量。

** 避免使用宏
   + 使用常量或枚举替代宏。
   + 使用函数替代宏函数。

** 提供更多的调试函数
   提供调试函数，方便在源码调试中调试自定义的数据结构。
* 第十二章 静态检查的作用
  1. 不要忽视编译器的警告。
  2. 使用多个编译器来检查代码。
  3. 使用静态分析工具。例如coverity，codecheck
  4. 静态分析的高级应用：
	 + 可移植性。
	 + 反向工程。
	 + 代码统计。
	 + 安全性。
