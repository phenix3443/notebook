# -*- coding:utf-8 -*-
#+title:关于程序语言的思考
#+author:刘尚亮
#+email:phenix3443@gmail.com



实际上， *程序就是 CPU 不断操作存储设备（内存和寄存器）的过程* 。

这就衍生出两个问题：
1. 如何操作？
2. 操作区域？

对存储区域的操作无非就四种：增（分配）、删（释放）、改（修改存储内容）、查（获取存储内容）。

现代操作系统中把所有的存储设备抽象为虚拟内存模型，虚拟内存地址如何映射到存储设备涉及存储设备的寻址方式：基址寻址，变址寻址等等，这里不展开讲这部分内容。

在虚拟内存模型中，所有存储区域都用内存地址来表示。内存地址是一串十六进制的编号，不便记忆，所以才有可读意义的 *标识符* 。我们可以认为 *标识符是内存地址的别称* 。

最接近机器语言的是汇编语言，每条汇编语句都可以转换为一条或多条机器指令。汇编指令由两部分构成：操作码和操作数，操作码指明了操作的动作，操作数指明待操作的地址。

但内存起始地址+偏移量才能指定一个操作范围，操作数只指明起始地址，那偏移量在哪里指定呢？熟悉汇编语言就知道，这部门内容就包含在操作码当中了，比如 addw，w 就表明是一个字的范围。 也就是说 *汇编语言是无类型的语言* ，汇编语言中的标识符没有类型说明。

既然无类型的汇编语言已经可以编程了，那么为什么我们还需要有类型的高级语言呢？

* 类型系统[fn:2]
  在计算机科学中，类型系统用于定义如何将编程语言中的 *数值和表达式* 归类为许多不同的类型，如何操作这些类型，这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的（虽然某些类型，如抽象类型和函数类型，在程序运行中，可能不表示为值）。 类型系统提供的主要功能有：[fn:1]

  + 安全性

	使用类型可允许编译器侦测无意义的，或者是可能无效的代码。例如，可以识出一个无效的表达式 "Hello, World" + 3，因为不能对（在平常的直觉中）逐字字符串加上一个整数。强类型提供更多的安全性，但它并不能保证绝对安全（详情请见类型安全）。安全性检查分静态类型检查和动态类型检查。

  + 优化

	静态类型检查可提供有用的信息给编译器来进行优化生成的机器指令。例如 C 中的结构体对齐。

  + 可读性

	在更具表现力的类型系统中，更容易阐明程序设计者的意图。例如 size_t 其实是 uint_32 的别称，但是 size_t 更明确的表明这个类型是说明 size 的，典型的就是 typedef 的使用。

  + 抽象化

	*抽象才是引入类型系统最重要的原因* 。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如可以将人抽象为一个结构体或类，其中的字段代表人的属性（名字，年龄等），该类型对象映射到内存中依旧是一段二进制数据，但二进制数据明显不便于我们操作。 *如果说高级语言中的类型是对数据集合的抽象，那么函数是对指令集合的抽象，包含局部变量的函数就是数据和指令的集合* ，从这个角度看， *函数是一种特殊的数据类型，参数和返回值指明了函数的类型* 。

** 静态类型和动态类型

   编程语言目前分：
   + 静态类型：变量类型在编译期确定，例如 C/C++、Java 等。
   + 动态类型：变量类型在运行时确定，例如 python、shell 等。
   静态类型语言中，声明将标识符和其类型进行绑定，之后不能改变。与其操作（比如赋值）的其他变量只能是相同类型（意味着相同大小的内存）的标识符，想想 C/C++中的类型转换。

   静态类型语言中的标识符使用之前要先声明，但要记住 *赋值操作才会分配内存* ，操作只声明而没有赋值的标识符可能会引发段错误。思考以下问题并做练习：
   + C/C++中标识符声明在文件作用域和函数作用域中的区别。
   + 使用没有赋值的 extern 关键字。
   + C/C++中的在不同区域声明的标识符如何初始化。

   动态型语言则相反，标识符并没有和类型绑定，也就不需要声明。标识符可以通过赋值引用任意内存块。此时标识符只是 *某一对象的别名* ，该对象才是绑定类型的内存块， 比如 python 和 lua 中的标识符。

   但是为了保证操作标识符的时候真的在操作内存块，所以动态类型语言规定标识符使用前必须赋值。（ *赋值才有内存分配* ）

   静态、动态类型语言各有什么优缺点呢？

   静态类型语言的主要优点在于其结构非常规范，便于调试，方便类型安全；缺点是为此需要写更多的类型相关代码，导致不便于阅读、不清晰明了。

   动态类型语言的优点在于方便阅读，不需要写非常多的类型相关的代码；缺点自然就是不方便调试，命名不规范时会造成读不懂，不利于理解等。


** 作用域（scope）
   为了描述标识符与内存区域的绑定关系，引入了作用域的概念。

   + 静态作用域（词法作用域）

	 + 文件作用域（static）
	 + 类作用域（public，private，friend）
	 + 函数作用域：了解函数中的 static 变量在内存中的布局（todo）
	 + 块作用域

   + 动态作用域

   + 作用域和命名空间的区别？

   + 作用域是如何实现的？

	 作用域是编译前端里面的概念，前端编译后，标识符就都映射到寄存器或调用栈上了。

* 语句（statement）

   *语句定义了指令* ：
   + 赋值语句中的左值对应内存的增、改，右值对应查。
   + 内存释放语句（free，delete）、垃圾回收机制对应释放内存（删）。
   + 控制语句，有三种基本的结构来控制指令的执行流程：
	 + 顺序结构
     + 选择结构（if，switch）
     + 循环结构（while，until，for）

* 语言学习

  高级语言的学习要点有两点：语法和程序库。

** 语法

   对于语法，根据上面的分析，其实就是类型和语句的学习。

*** 类型
	掌握各种类型的的增删改查操作，内存大小，作用域范围，以及相互之间的转换。

**** 基本类型

***** 数字
	  + 所占内存大小
	  + 数学操作中的隐式转换
	  + 不同进制间的转换

***** bool
	  + 真假的规则

***** byte

**** 复合类型
	 + 内存存储方式
	 + 各字段的增删改查操作，注意是否原地修改。

***** 序列

***** 字典

*** 语句
**** 表达式语句
	表达式（expression）由标识符和操作符可以组成。表达式和语句的区别：表达式有值，语句没有值。 能作为函数参数即为表达式，否则为语句。

***** 操作符
****** 算术
****** 逻辑
****** 二进制
****** 赋值

**** 控制语句
***** 顺序

***** 选择

***** 循环

** 相关的库
*** 数学
*** 字符串处理
*** 正则表达
*** 输入输出
*** 数学
*** 日期、时间和本地化
*** 动态分配
*** 网络
*** 邮件
*** 并发

** 工具

*** 调试工具

*** 文档话工具

*** 代码检查

*** 性能测试

* Footnotes

[fn:2] [[http://dev.gameres.com/Program/Other/bcxszyforgameres/bcxszy/xisofts.sinaapp.com/@p=88.htm][语言的类型系统]]

[fn:1] [[https://zh.wikipedia.org/wiki/%25E9%25A1%259E%25E5%259E%258B%25E7%25B3%25BB%25E7%25B5%25B1][类型系统]]
