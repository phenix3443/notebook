# -*- coding:utf-8 -*-
#+TITLE: docker in action 笔记
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com
#+OPTIONS: num:nil

* 1 什么是 docker

** 1.1 什么是 docker
   docker 包括一个命令行程序，一个后台守护进程，以及一组远程服务。它解决了常见的软件问题，并简化了安装、运行、发布和删除软件。

   docker 实现隔离的八个方面。

* 2 在容器中运行软件
  帮助容器建立与环境无关系统的三个特定功能：
  + 只读文件系统
  + 环境变量注入
  + 存储卷

  Page17 建立邮件程序的命令是： =docker run -d --name mailer dockerinaction/ch2_mailer=

  docker logs

  cid=$(docker create nginx)

  docker ps -l -q

  docker rename

  docker run --restart always -e 环境变量

  docker rm -rm

  docker rm  -vf $(docker ps -a -q)

* 3 查找和安装软件

  docker save -o myfile.tar busybox

  docker load -i myfile.tart

  docker build -t <tag> <dockerfile>

  union 文件系统对文件系统进行了隔离。它的缺点：
  + 在不同文件系统规则间切换可能会有问题。
  + 使用的写时复制的模式使得内存映射文件（mmap（）系统调用）实现困难。

* 4 持久化存储和卷间状态共享
** 4.1 存储卷提供容器无关的数据管理方式
   存储卷是一个数据分割和共享的工具，有一个与容器无关的范围或生命周期。

   镜像适合打包和分发相对静态的文件，存储卷则持有动态或专门数据。

** 4.2 存储卷的类型
   不管哪种存储卷，本质上都是将主机文件系统挂在到容器文件系统中。
*** 4.2.1 挂载卷
    绑定挂载存储卷（简称挂载卷）：使用用户提供主机目录或文件

    注意：
    + 如果指定主机目录不存在，docker 会自动创建。
    + 绑定的文件必须在主机上存在，否则会被 docker 当成目录创建。

    缺点：
    + 将可移植容器绑定到特定主机的文件系统。
    + 创造了与其他容器发生冲突的机会。

*** 4.2.2 管理卷
    管理存储卷（简称管理卷）：使用由 Docker 守护进程控制的位置，称为 Docker 管理空间。
    + 可以用来解耦存储卷。

** 4.3 共享存储卷

*** 4.3.1 主机依赖间的共享
    多个容器都挂载在主机的同一目录。

*** 4.3.2 volumes-from 标志
    通过 volumes-from 复制源容器定义的所有键，通过该参数还可以直接或传递地复制卷。

** 4.4 管理卷的生命周期

*** 4.4.1 管理卷的权限
    区分存储卷的最好方法是每个管理卷都定义一个容器。

*** 4.4.2 存储卷的清理
    Docker 守护程序无法删除挂载卷。

    删除容器时，使用 =-v= 参数的 =docker rm= 命令试图删除目标容器中引用的任何管理卷。 *删除容器最好带上 =-v= 参数*

    如果删除每个已引用管理卷的容器，但是没有使用 =-v= 标志，就会产生孤立卷。移除孤立卷需要手工操作。

** 4.5 存储卷的高级容器模式
*** 4.5.1 卷容器模式
    卷容器： *只提供卷句柄的容器* 。卷容器停止时仍能保证存储卷的引用。

    使用卷容器要求能控制并使挂载点的命名管理标准化。

*** 4.5.2 数据打包的存储卷容器
    用来将 *镜像中的* 静态内容复制到 *其定义的存储卷* 。（注意方向）这些容器可用于分发关键架构信息，如配置，秘钥材料和代码。这是多态容器模式的基础。

*** 4.5.3 多态容器模式
    将文件注入静态容器（例如程序）来改变所有类型的行为。

    可以通过将 openresty-develop-framework 做成一个 docker 镜像，然后将具体的业务代码做成数据打包的存储卷容器，二者结合实现具体的不同业务。

* 5 网络访问
  容器和主机的网络访问主要包括：
  + 单主机网络
    + 容器和主机
    + 容器和主机网络
    + 容器和容器
  + 多主机网络

** 5.1 网络相关的背景知识
   Docker 创建了一种虚拟网络，称之为网桥，目的是让所有正在运行的容器能够连接到主机网络。

** 5.2 Docker 的网络
   每隔容器都各自拥有一个本地回环接口和一个分离的以太网接口，其中以太网接口连接着 *主机命名空间* 上的 *另外一个虚拟接口* （注意不是直接和 docker0 连接）。这两个互连的接口在主机网络栈和每个容器的网络栈之间建立了连接。

   docker 用内核命名空间来创建这些所有的虚拟接口，但是命名空间本身并不提供网络的隔离。网络暴露或者隔离是通过主机的防火墙规则实现的。


** 5.3 Closed 容器

** 5.4 Bridged 容器
   所有连接到 docker0 接口的虚拟接口都是同一虚拟子网的一部分分。这意味着它们能够互相通信，并且能够通过 docker0 接口和外部的网络进行通信。

   使用 =--hostname= 自定义容器的主机名。这个选项会在容器的 DNS 覆盖系统（如/etc/hosts）中添加一条记录。

   使用 =--dns= 指定 DNS 服务器。

   使用 =--dns-search= 指定 dns 查找域。指定默认的查找后缀，比如公司的外网机器的默认域名。

   使用 =--add-host= 用来覆盖 dns 系统查找记录。可以在 mock 第三方接口的时候用到。

   修改网桥的配置，可以用来配置 IP 测试环境。

** 5.5 Joined 容器
   如果其中一个容器的进程需要与另外一个进程在一个未开放的端口上进行通信，最佳的方式就是链接这两个容器。

   使用场景：
   + 当想要不同的容器上的程序通过本地回环地址进行通信时
   + 当一个容器的程序想要改变 joined 网络栈，而另外一个程序正好需要改变的网络栈
   + 想要监控另外一个程序中某个程序的网络流量。

** 5.6 Open 容器

** 5.7 跨容器依赖

   链接（ =--link= ）的本质是静态的、具有方向性和无传递性的网络依赖。注意：方向性是指服务发现，而不是通信。

* 6 隔离-限制危险
  对 docker 使用宿主机资源的限制

  对 docker 账号，组的隔离。

* 7 从容器构建镜像

** 7.1 从容器构建镜像

** 7.2 深入 Docker 镜像和层

** 7.3 导出和导入扁平文件系统

** 7.4 版本控制的最佳实践

* 8 构建自动化和高级镜像设置

** 8.1 使用 Dockerfile 打包 Git
   特定的空镜像:scratch。

   docker build 的-f 参数只能设置文件名字，不能设置文件位置。

   Dockerfile 中 每个指令都会创建一个新容器，然后做指定的修改，当修改完成后，构建程序会提交新容器，然后以同样的方式执行下一条指令。

** 8.2 Dockerfile 入门

   Dockerfile 可以简化将文件复制从计算机复制到镜像的过程。启动新项目第一件事情应该使用 =.dockerignore= 指定不需要复制到镜像中的文件。

   每个 Dockerfile 指令都会导致一个新层被创建，指令应该尽可能合并，因为构建程序不会进行任何优化。

   使用 exec 格式是最佳实践。

   CMD 指令表示入口点的一个参数列表。

   ADD 指令类似 COPY 指令，不同点在于：
   + 如果指定一个 url，会拉取远程源文件。（不是好的实践，因无法清理）
   + 会将判定位存档文件的源中的文件提取出来。

** 8.3 注入下游镜像在构建时发生的操作
   ON_BUILD 指令。

** 8.4 使用启动脚本和多进程容器

** 8.5 加固应用镜像

* 9 公有和私有软件分发

* 10 运行自定义的 registry

* 11 docker compose 声明式环境

* 12 docker machine 和 swarm 集群

* 其他知识点
  + LXC
  + cgroup
  + chroot
  + union 文件系统
  + MNT 命名空间
