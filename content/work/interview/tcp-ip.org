# -*- coding:utf-8-*-
#+TITLE:TCP/IP
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com


* TCP/IP 五层以及每层对应的协议
  + 物理层
  + 链路层：
  + 网络层：IP，ICMP，ARP，RARP
  + 传输层：TCP，UDP
  + 应用层：HTTP，FTP，SMTP，TELNET，NFS

* OSI 七层以及每层对应的协议
  + 物理层
  + 链路层
  + 网络层
  + 传输层
  + 会话层
  + 表示层
  + 应用层

* IP
** 协议格式

** 校验和只校验 IP 协议首部？为什么不是整个 IP 报文？

* TCP 和 UDP 区别
  + TCP 提供面向连接、可靠的字节流服务。
    + 面向连接是指
      + 使用 TCP 协议通信的双方必须先建立连接，然后才能开始数据的读写。双方必须为该连接分配必要的内核资源，以管理连接的状态和连接上的数据传输。完成数据交换后，通信双方都必须断开连接以释放系统资源。
      + TCP 连接是全双工的，即双方的数据读写可以通过一个连接进行。
      + TCP 协议的这种连接是一对一的，所以基于广播和多播的应用程序不能使用 TCP 服务，而无连接协议 UDP 则非常适合广播和多播。
    + TCP 通过发送应答、超时重传、报文重组等方法保证数据的可靠传输。
    + 字节流服务体现在实际编程上表现为通信双方应用程序对数据的发送和接收是没有边界的。另外 TCP 模块发送 TCP 报文段的个数和应用程序执行的读写操作的次数之间没有固定的数量关系。

  + UDP 数据报协议。
    + UDP 不需要建立连接，所以发送速度较快。
    + UDP 协议和 IP 协议一样，它们都需要上层协议来处理数据确认和超时重传。
    + 发送端应用程序每执行一次写操作，UDP 模块就将其封装为一个 UDP 数据报并发送。接受端必须及时针对每一个 UDP 数据报执行读操作，否则就会发生丢包。

* TCP

** 协议格式
   + 源端口、目的端口(socketpair)
   + 序列号
     + 当一端为建立连接而发送它的 SYN 时，它为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。RFC 793[Postel 1981c]指出 ISN 可看作是一个 32 比特的计数器，每 4ms 加 1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释。
     + 主机要发送数据的第一个字节序号为这个 ISN 加 1，因为 syn 标志小号一个序号，FIN 也消耗一个序号。
   + 确认号
     + TCP 可以表述为一个没有选择确认或否认的滑动窗口协议。我们说 TCP 缺少选择确认是因为 TCP 首部中的确认序号表示接收方已成功收到字节，但还不包含确认序号所指的字节。当前还无法对数据流中选定的部分进行确认。例如，如果 1～1024 字节已经成功收到，下一报文段中包含序号从 2049～3072 的字节，收端并不能确认这个新的报文段。它所能做的就是发回一个确认序号为 1025 的 ACK。它也无法对一个报文段进行否认。例如，如果收到包含 1025～2048 字节的报文段，但它的检验和错，TCP 接收端所能做的就是发回一个确认序号为 1025 的 ACK。
   + 首部长度
     + 单位是 32 字长度，所以首部最多 60 字节。
   + 保留选项
   + 标志
     + URG
     + ACK
     + PSH
     + RST
       + 无论何时一个报文段发往基准的连接（referenced connection）出现错误，TCP 都会发出一个复位报文段。
       + 也有可能发送一个复位报文段而不是 FIN 来中途释放一个连接。有时称这为异常释放（abortive release）。异常终止一个连接对应用程序来说有两个优点：
         + 丢弃任何待发数据并立即发送复位报文段；
         + RST 的接收方会区分另一端执行的是异常关闭还是正常关闭。应用程序使用的 API 必须提供产生异常关闭而不是正常关闭的手段。
       + 半打开连接：TCP 的处理原则是接收方以复位作为应答。
     + SYN
     + FIN 支持半关闭。
   + 窗口大小
     + 单位字节数，默认 4096，因为 4096 是 NFS 读写数据的大小。
   + 检验和
     + 覆盖 TCP 整个报文段。
     + 强制使用。
   + 紧急指针
   + 选项
     + 最大报文段长度（MSS）
       + 每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段避免分段。
       + 该字段通常 1024，所以 IP 数据报通常是 40 字节长：20 字节的 TCP 首部和 20 字节的 IP 首部。

** 连接状态图
   + 被动关闭
     + CLOSE_WAIT
     + LAST_ACK
   + 主动关闭
     + FIN_WAIT_1
     + FIN_WAIT_2
     + CLOSING
     + TIME_WAIT
       + TIME_WAIT 状态也称为 2MSL 等待状态。每个具体 TCP 实现必须选择一个报文段最大生存时间 MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。
       + 当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的 MSL。这样可让 TCP 再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的 FIN）。
       + 这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（客户的 IP 地址和端口号，服务器的 IP 地址和端口号）不能再被使用。这个连接只能在 2MSL 结束后才能再被使用。
       + 在连接处于 2MSL 等待时，任何迟到的报文段将被丢弃。
       + RFC793 定义了 MSL 为 2 分钟，Linux 设置成了 30s
       + TIME_WAIT 数量太多：十有八九的处理方式都是教你设置两个参数，一个叫 tcp_tw_reuse，另一个叫 tcp_tw_recycle 的参数，这两个参数默认值都是被关闭的，后者 recyle 比前者 resue 更为激进，resue 要温柔一些。另外，如果使用 tcp_tw_reuse，必需设置 tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让 TCP 连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“It should not be changed without advice/request of technical experts”）。

         Again，使用 tcp_tw_reuse 和 tcp_tw_recycle 来解决 TIME_WAIT 的问题是非常非常危险的，因为这两个参数违反了 TCP 协议（RFC 1122）。

         其实，TIME_WAIT 表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于 HTTP 服务器，那么设置一个 HTTP 的 KeepAlive 有多重要。

*** tcp_tw_reuse：
    官方文档上说 tcp_tw_reuse 加上 tcp_timestamps（又叫 PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要 tcp_timestamps 在两边都被打开（你可以读一下 tcp_twsk_unique 的源码 ）。我个人估计还是有一些场景会有问题。

*** tcp_tw_recycle：
    如果是 tcp_tw_recycle 被打开了话，会假设对端开启了 tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个 NAT 网络的话（如：一个公司只用一个 IP 出公网）或是对端的 IP 被另一台重用了，这个事就复杂了。建链接的 SYN 可能就被直接丢掉了（你可能会看到 connection time out 的错误）（如果你想观摩一下 Linux 的内核代码，请参看源码 tcp_timewait_state_process）。

*** tcp_max_tw_buckets：
    这个是控制并发的 TIME_WAIT 的数量，默认值是 180000，如果超限，那么，系统会把多的给 destory 掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗 DDoS 攻击的。也说的默认值 180000 并不小。这个还是需要根据实际情况考虑。

** 呼入连接请求队列（backlog）
   1. 正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被 TCP 接受（即三次握手已经完成），但还没有被应用层所接受。注意区分 TCP 接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
   2. 应用层将指明该队列的最大长度，这个值通常称为积压值(backlog)。它的取值范围是 0~5 之间的整数，包括 0 和 5（大多数的应用程序都将这个值说明为 5）。

   3. 当一个连接请求（即 SYN）到达时，TCP 使用一个算法，根据当前连接队列中的连接数来确定是否接收这个连接。我们期望应用层说明的积压值为这一端点所能允许接受连接的最大数目，但情况不是那么简单。

      注意，积压值说明的是 TCP 监听的端点已被 TCP 接受而等待应用层接受的最大连接数。这个积压值对系统所允许的最大连接数，或者并发服务器所能并发处理的客户数，并无影响。
   4. 如果对于新的连接请求，该 TCP 监听的端点的连接队列中还有空间，TCP 模块将对 SYN 进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接时。另外，当客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了（如果发生这种情况，服务器的 TCP 仅将接收的数据放入缓冲队列)。
   5. 如果对于新的连接请求，连接队列中已没有空间，TCP 将不理会收到的 SYN。也不发回任何报文段（即不发回 RST）。如果应用层不能及时接受已被 TCP 接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。

** 如何保证可靠传输？
   + 数据分段，应用层数据被分割为最合适发送的数据块。
   + 流量控制
   + 接受确认
   + 超时重传
   + 重新排序
   + 检验和
   + 丢弃重复

** 超时重传
   超时和重传的策略关键：怎样决定超时间隔和如何确定重传频率。

   对于每个连接，TCP 管理 4 个不同的定时器：
   + 重传定时器，希望得到对方确认。
   + 坚持定时器（persist），使窗口大小信息保持不断流动。
   + 保活定时器（keepalive），检测空闲连接的另一端何时崩溃或重启。
   + 2MSL 定时器，测量一个处于 TIME_WAIT 状态的时间。

** 快速重传与快速恢复
   对于发送端，由于我们不知道一个重复的 ACK 是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的 ACK 到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的 ACK 之前，只可能产生 1~2 个重复的 ACK。如果一连串收到 3 个或 3 个以上的重复 ACK，就非常可能是一个报文段丢失了（我们在 21.5 节中见到过这种现象）。于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。

** SACK 方法

   解决上面问题另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看 RFC 2018），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。

   这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过 tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。

** 滑动窗口

*** Zero Window
    TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。

*** Silly Window Syndrome（糊涂窗口综合增）
    Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端：

    + 如果这个问题是由 Receiver 端引起的，那么就会使用 David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。
    + 如果这个问题是由 Sender 端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size>=MSS 或是 Data Size >=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。

** 拥塞控制
   拥塞标志：发生超时和接收到重复的确认。

   拥塞控制主要是四个算法：
   + 慢启动

     连接上最初只允许传输一个报文段，然后在发送下一个报文段之前必须等待接收它的确认。当报文段 2 被接收后，就可以再发送两个报文段。

   + 拥塞避免

     拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。

   + 拥塞发生
   + 快速恢复

   拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口 cwnd 和一个慢启动门限 ssthresh。这样得到的算法的工作过程如下：
   1. 对一个给定的连接，初始化 cwnd 为 1 个报文段，ssthresh 为 65535 个字节。
   2. TCP 输出例程的输出不能超过 cwnd 和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。
   3. 当拥塞发生时（超时或收到重复确认），ssthresh 被设置为当前窗口大小的一半（cwnd 和接收方通告窗口大小的最小值，但最少为 2 个报文段）。此外，如果是超时引起了拥塞，则 cwnd 被设置为 1 个报文段（这就是慢启动）。
   4. 当新的数据被对方确认时，就增加 cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果 cwnd 小于或等于 ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤 2 中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。

   慢启动算法初始设置 cwnd 为 1 个报文段，此后每收到一个确认就加 1。正如 20.6 节描述的那样，这会使窗口按指数方式增长：发送 1 个报文段，然后是 2 个，接着是 4 个......。

   拥塞避免算法要求每次收到一个确认时将 cwnd 增加 1/cwnd。与慢启动的指数增加比起来，这是一种加性增长(additive increase)。我们希望在一个往返时间内最多为 cwnd 增加 1 个报文段（不管在这个 RTT 中收到了多少个 ACK），然而慢启动将根据这个往返时间中所收到的确认的个数增加 cwnd。

* UDP
** 协议格式
   + 报文长度
     + 首部中的长度是数据报长度还是协议首部长度？为什么要有该字段？该字段的最大长度是多少？默认长度是多少？为什么是这些值？
   + 校验和
     + 可选

** ICMP 底层是 UDP 还是 TCP？

** 如何设计 UDP 为可靠传输？
   设计方案：
   1. 添加 seq/ack 机制，确保数据发送到对端
   2. 添加发送和接收缓冲区，主要是用户超时重传。
   3. 添加超时重传机制。

   目前有如下开源程序利用 udp 实现了可靠的数据传输。分别为 RUDP、RTP、UDT、KCP、QUIC 等。

* 弱网络环境下如何保证数据传输？

* 粘包断包问题

* Footnotes

[1] http://www.52im.net/thread-515-1-1.html
