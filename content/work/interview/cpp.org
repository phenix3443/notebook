# -*- coding:utf-8-*-
#+TITLE: C/C++
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 指针和引用区别
  *指针本身是对象* 。可以不初始化，可以通过赋值重新指向别的对象。

  *引用不是对象，只是对象的别名* ，这是引用的本质，很多引用的特性都基于此：
  + 必须初始化。
  + 不能重新绑定。由于所有对引用的操作都是作用于绑定的对象本身，所以无法将引用重新绑定到别的对象。
  + 没有引用的引用。因为引用不是对象，也不能定义引用的引用。
  + 和对象类型阉割匹配。
  + 引用只能绑定在对象上，不能是字面值或者某个表达式的计算结果。

  为什么需要引用？
  1. 引用作为变量的短名字，代码更清晰。而且指针是对象，占用内存，引用只是别名，不占用内存（标准规定）。
     #+BEGIN_SRC c++
auto& nDays =  Month[monthindex].NumberOfDays;
     #+END_SRC
     如果不这样使用，可能要使用指针或赋值给新的变量，都会有内存开销。

     目前编译器实现中，引用底层使用指针实现的，但是编译器可能对此有优化，所以有时候可以不用内存空间。

  2. 引用通常用在函数参数，或者返回值。相比指针：
     1. 写法更简单。

        第二种函数调用，单从使用就知道输入参数和输出参数。而且 input 在使用过程中，还不用加 =*= 。

     2. 比指针更安全，指针可能为空，使用需要进行判断，而引用则不需要。

* 函数

** 重载（overload）、 重写（override）和重定义（redefining）
   重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

   重写是指子类重新定义的父类中有相同的名称或者参数的虚函数，主要在继承关系中出现。
   + 子类重写父类中的 virtual 函数。
   + 重写函数和被重写函数的函数名签名必须一致。
   + 重写函数和被重写函数都是 virtual 函数。


   函数重定义（也叫隐藏），子类重定义父类中的非虚函数，屏蔽了父类的同名函数(相当于创建了一个新的函数，跟父类无关)
   + 子类和父类函数的名称相同，参数也相同，父类中的函数不是 virtual，父类的函数将被隐藏
   + 子类和父类的函数名称相同，但参数不同，此时不管父类函数是不是 virtual 函数，都将被隐藏。

** 函数重载中 name mangle 具体过程
** auto_ptr 为什么不能作为容器的元素？
** 重载、覆盖、重写区别

* 类
** 在什么情况下编译器不会为类合成默认构造函数？
   1. 如果类已经有任何构造函数。
   2. 如果类成员没有默认构造函数，无法初始化该成员。

** 纯虚函数和虚函数的区别
   纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在很多情况下，基类本身生成对象是不合情理的。

   虚函数是为了允许用基类的指针来调用子类的这个函数。 虚函数只能借助于指针或者引用来达到多态的效果。

** 虚表

* C++内存模型


* STL
** 底层实现方式
   + vector	数组
   + list	双向链表
   + deque	数个缓冲区相接，由一个中央控制器管理
   + set	红黑树
   + map	红黑树
   + multiset	红黑树
   + multimap	红黑树
   + unordered_set	哈希表
   + unordered_map	哈希表
   + unordered_multiset	哈希表
   + unordered_multimap	哈希表
