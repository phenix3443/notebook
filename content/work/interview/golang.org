# -*- coding:utf-8-*-
#+TITLE: golang
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* go 语言优点
  1. 性能和 C++差不多，但是语言很简单，更容易上手开发。
  2. 各种包比较丰富，而且有好用的包管理工具。
  3. 并发非常容易上手。
  4. 有垃圾回收机制。
  5. 有比较稳定的生态系统，有很好用的开发工具链。


* 基本结构和数据类型

** =var a []int= 和 ~a := []int{}~ 是否有区别？在开发过程中使用哪个更好，为什么？

   首先，从赋值形式来看，二者都可以用于声明变量，前者主要用于声明包级别的全局变量，后者主要用于函数体内部的声明和初始化局部变量。

   其次，最重要的区别是：
   + 前者没有只是声明了引用形式，没有分配内存。
   + 后者大括号初始化的形式声明内存。

     #+BEGIN_SRC go
func TestSliceSpace(t *testing.T) {
	var s1 []int
	s2 := []int{}
	fmt.Printf("s1=%p,s2=%p\n", s1, s2) // s1=0x0,s2=0x1268f58
}
     #+END_SRC


** 类型断言和类型转换的区别
   类型断言是用来从一个接口里面读取数值给一个具体的类型变量。

   类型转换是指转换两个不相同的数据类型。

** 拼接字符串的方式
   + 使用加号
   + 使用 strings.join
   + 使用 bytes.Buffer

* 控制结构
** select 作用
  golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作

  每个 case 语句里必须是一个 IO 操作，确切的说，应该是一个面向 channel 的 IO 操作

* 函数
** 匿名函数，闭包

* 数组与切片
** Go 中，如何复制切片内容？
** slice 内部实现
  Go 中切片扩容的策略是这样的：
  + 首先判断，如果新申请容量（cap）大于 2 倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）
  + 否则判断，如果旧切片的长度小于 1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）
  + 否则判断，如果旧切片长度大于等于 1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
  + 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）

  注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

  https://halfrost.com/go_slice/

* map
** map 内部实现
  哈希表解决冲突一般要么是开放定址法，要么是再哈希法。Golang 采用的是第一种，但是实现上和教科书式的实现方式不同。

  map 的底层结构是 hmap（即 hashmap 的缩写），核心元素是一个由若干个桶（bucket，结构为 bmap）组成的数组，每个 bucket 可以存放若干元素（通常是 8 个），key 通过哈希算法被归入不同的 bucket 中。当超过 8 个元素需要存入某个 bucket 时，hmap 会使用 extra 中的 overflow 来拓展该 bucket。

  https://www.linkinstar.wiki/2019/06/03/golang/source-code/graphic-golang-map/

*** get
   下面说明要点：
   + 计算出 key 的 hash
   + 用最后的“B”位来确定在哪个桶（“B”就是前面说的那个，B为 4，就有 16 个桶，0101 用十进制表示为 5，所以在 5 号桶）
   + 根据 key 的前 8 位快速确定是在哪个格子（额外说明一下，在 bmap 中存放了每个 key 对应的 tophash，是 key 的前 8 位）
   + 最终还是需要比对 key 完整的 hash 是否匹配，如果匹配则获取对应 value
   + 如果都没有找到，就去下一个 overflow 找

*** 疑问
   + 删除掉 map 中的元素是否会释放内存？

     不会，删除操作仅仅将对应的 tophash[i]设置为 empty，并非释放内存。若要释放内存只能等待指针无引用后被系统 gc。

   + 如何并发地使用 map？

     map 不是 goroutine 安全的，所以在有多个 gorountine 对 map 进行写操作是会 panic。多 gorountine 读写 map 是应加锁（RWMutex），或使用 sync.Map（1.9 新增，在下篇文章中会介绍这个东西，总之是不太推荐使用）。

   + map 的 iterator 是否安全？

     map 的 delete 并非真的 delete，所以对迭代器是没有影响的，是安全的。

** 如何复制 map 内容？

* 包

* 结构和方法
** 在 Go 语言中，如何比较结构体。

** 空结构体 （struct{}）使用场景。
   空结构体不占用内存，所有孔结构体都返回固定的地址。可以用来：
   + 定义 set， set =make(map[int]struct{},100)
   + 定义 channel， c= make(chan struct{})

* 接口
** 如何比较接口
** 如何复制接口内容？编程时会如何操作实现。

* 错误处理

* 协程（goroutine）
** 什么是 goroutine，他与 process， thread 有什么区别？

** 抢占式 goroutine 是什么意思

** goroutine 实现、调度
https://wudaijun.com/2018/01/go-scheduler/

* 通道（channel）

** 除了 mutex 意外还有那些方式安全读写共享变量？

** 什么是 channel，为什么它可以做到线程安全

** channel 是通过注册相关 groutine id 实现消息通知的。

** channel 关闭原则
  https://juejin.im/post/5ac9e62e5188255c272234e3

  不要在消费端关闭 channel，不要在有多个并行的生产者时对 channel 执行关闭操作。

  也就是说应该只在[唯一的或者最后唯一剩下]的生产者协程中关闭 channel，来通知消费者已经没有值可以继续读了。只要坚持这个原则，就可以确保向一个已经关闭的 channel 发送数据的情况不可能发生。

** channel 缓冲区是使用循环队列实现的。

** 如何用 channel 实现一个令牌桶？

* fmt 系列函数内部实现
  1. 使用反射判断参数类型
  2. 基础函数都实现了打印函数。
  3. 未知类型看是否实现了 Formmater 接口
  4. 字符串格式看是否实现了 Stringer 接口。

  介绍：https://cloud.tencent.com/developer/article/1399913

  代码注释：https://www.cnblogs.com/pluse/p/8031386.html

* sync.Pool 有什么用处？

* sync.mutex 是怎么实现的，用了什么底层指令？

* 垃圾回收
** 回收原理
** 失效情形
** 什么是小对象？为什么小对象多了会造成 gc 压力？

* context 包的用途
  Context 通常被译作上下文，它是一个比较抽象的概念，其本质，是【上下上下】存在上下层的传递，上会把内容传递给下。在 Go 语言中，程序单元也就指的是 Goroutine

* 实现生产者和消费者


* 常见的坑
  + channel 一定要记得 close。
  + goroutine 记得 return 或者中断。
  + append slice 的时候要关注底层数组的变化。
  + http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html
  + for i,v :=range(slice) 中 v 是元素的复制。


* netgo，cgo 有什么区别？

* 如何调试一个 go 程序？
