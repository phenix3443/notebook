# -*- coding:utf-8-*-
#+TITLE: c 和指针
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com
#+STARTUP: overview
#+OPTIONS: author:nil date:nil creator:nil timestamp:nil validate:nil num:nil

* 第一章 快速上手
  使用 =#if= 指令从逻辑上删除一段代码。

  NUL 是 ASCII 字符集中 =\0= 字符的名字，它的字节模式为全 0，NULL 只一个其值为 0 的指针。它们都是整型值，其值也相同，所以它们可以互换使用。然而，还是应该使用适当的常量，因为它能告诉使用这个值的目的。

* 第二章 基本概念

* 第三章 数据
  作用域、链接属性、存储类型 -> 可视性和生命期

  基本数据类型：整型、浮点型、指针和聚合类型。

  缺省 char 是 signed 还是 unsigned 取决于编译器。

  八进制、十进制、十六进制缺省情况下是最短但能完全容纳这个值的类型。

  浮点数字面值缺省情况下都是 double 类型的。

  之所以选择 NUL 作为终止符，是因为它不是一个可打印的字符。

  应该使用 typedef 而不是 define 定义新的类型，因为后者无法正确处理指针。

** 3.5 作用域
  编译器可以确认 4 中不同类型的作用域：文件作用域、函数作用域、代码块作用域和原型作用域。

  标识符声明 *位置* 决定了它的作用域。

** 3.6 链接属性

   标识符的链接属性（linkage）决定如何处理不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但这两个属性并不相同。

   链接属性一共有 3 种：external（外部）、internal（内部）和 none（无）。

   没有链接属性地标识符（none） 总是被当做单独的个体，也就是说该标识符的多个声明被当做独立不同的个体。比如同一文件的全局变量和局部变量。

   属于 internal 链接属性的标识符在 *同一个源文件地所有声明* 都指同一个体，但位于不同源文件的多个声明则分属不同的实体。所以：

   + 头文件中 *不要定义* static 变量。因为被 include 到不同文件中的 static 变量都是不同的实体。[[https://github.com/phenix3443/test/tree/master/c/lang/static_var_in_h][示例代码]] 头文件中应该只有声明，没有定义。

   属于 extern 链接属性的标识符不管声明多少次、位于几个源文件都表示同一个体。

   关键字 extern 和 static 用于在声明中修改标识符的链接属性。

   文件作用域的变量默认是 extern 链接属性。

   如果某个声明在正常情况下具有 extern 链接属性（比如文件作用域的变量），在它前面添加 static 关键字可以使他的链接属性变为 internal。

   static 只有对 *缺省链接属性为 extern* 的声明才有改变链接属性的效果。反例：函数中没有链接属性关键字的表示符链接属性为 none。

   从技术来说，这两个关键字只有在声明中才是必须的。最佳实践：只用 extern 和 static 来定义声明。

   extern 关键字只有在标识符第一次声明的时候有效，标识符 2 及以上声明中的 extern 没有效果。

** 3.7 存储类型
   有三个地方可以用于存储变量：普通内存、运行时堆栈、硬件寄存器。

   变量的缺省存储类型取决于它的声明位置：
   + 凡是在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，称之为静态变量。（静态于堆栈的动态分配相对应）
   + 在代码块内部声明的变量的缺省存储类型是自动的（自动表示堆栈上内存的自动分配），auto 关键字可用于修饰此类变量。
   + 对于代码块内声明的变量，如果给它加上 static 关键字，它的存储类型就从自动变成静态。但是注意： 这并不改变变量的作用域。
   + 函数的形参不能声明为静态，因为实在总是在堆栈中传递给函数，用于支持递归。
   + register 声明自动变量的声明， *提示* 它们应该被存储在寄存器中，但是编译器可以不管。

* 第四章 语句
  c 并不具备专门的赋值语句，而是统一使用“表达式语句”代替。

** 4.8 switch
   switch 中的 case 标签并不把语句列表划分为几个部分，它们只是确定语句列表的进入点。 参见[[https://github.com/phenix3443/test/blob/master/c/lang/switch.c][switch.c]]

* 第五章 操作符和表达式
** 5.1 操作符
   移位操作符：逻辑移位和算术移位。标准说明无符号值执行的所有移位操作都是逻辑移位，但对于有符号值，取决于编译器。

   sizeof 的操作数既可以是表达式，也可以是两边加上括号的类型名。（注意类型名必需加上括号）

   判断表达式的长度并不需要对表达式进行求值，所以 =sizeof(a=b+1)= 并没有向 a 赋值。参见[[https://github.com/phenix3443/test/blob/master/c/lang/sizeof.c][sizeof.c]] （什么情况下需要判断表达式的长度？）

   抽象的说，前缀和后缀形式的增值操作符都复制了一份变量值的 *拷贝* 。用于周围表达式的值正是这份拷贝。前缀操作符在进行赋值之前增加变量的值，后缀操作符在进行赋值之后才增加变量的值。 *这些操作符的结果不是被它们所修改的变量，而是变量值的拷贝* 。认识这点非常重要，因为它解释了为什么不能向下面这样使用这些操作符：
   #+BEGIN_SRC c
++i = 10;
   #+END_SRC

   关系操作符的结果是整型值，因而可以赋值给整型变量。

   逗号操作符
* 第六章 指针
** 6.1 内存和地址
   内存以字节座位寻址单位。

** 6.2 值和类型
   不能简单地通过检查一个值的位来判断它的类型。 要结合它砸及程序中的使用方式。

* 第七章 函数
** 7.5 递归
   尾递归可以很容易转换成循环。

* 第八章 数组

* 第九章 字符串、字符和字节
  + strlen
  + strcpy
  + strcat
  + strcmp
  + strncpy
  + strncat
  + strncmp
  + strchr
  + strrchr
  + strpbrk
  + strstr
  + strtok
  + strerror

* 第十章 结构和联合

* 第十一章 动态内存分配

* 第十二章 使用结构和指针

* 第十三章 高级指针话题

* 第十四章 预处理器
