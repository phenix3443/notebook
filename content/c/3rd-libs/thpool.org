# -*- coding:utf-8-*-
#+TITLE: thpool
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 概述
  [[https://github.com/Pithikos/C-Thread-Pool][thpool]] 是一个小而高级的线程池实现。特性：
  + 符合 ANCI C 和 POSIX 标准
  + 暂停/恢复/等待
  + 简单易于理解的 API
  + 经过充分测试
  + MIT 许可

* 安装

* 使用

* faq

** 为什么 pthread_exit()不用于退出线程？
   thread_do 曾经使用过 pthread_exit()，但这使得难于测试内存泄漏。因为调用 pthread_exit()时，pthread 并没有释放所有内存 （可能是为了将来的线程或错误地认为应用程序正在终止）。由于这些原因只是简单返回。

   有趣的是，使用 pthread_exit()会导致分配更多的内存。

** 为什么在调用 thpool_destroy()之后使用 sleep()？
   这仅在测试中需要。如果你调用 thpool_destroy 后立即退出，程序可能在所有线程解除分配之前退出。以这种方式，不可能检查内存泄漏。

   在生产中不必担心这个，因为如果在销毁池之后立即调用 exit，那么线程将被操作系统释放。如果在程序中间销毁池也无关紧要，因为程序不会立即退出，因此线程将有足够的时间来终止。

** 为什么 wait()使用所有的 CPU？
   注意：截至 2015 年 12 月 11 日，wait()不再使用轮询。而是使用条件变量，因此理论上不应该有任何 CPU 开销。

   通常，wait()会在调用时将 CPU 使用率提高到满。这是正常的，只要它不会持续超过 1 秒。发生这种情况的原因是 wait()经历了轮询的各个阶段（所谓的智能轮询）。
   + 最初轮询之间没有间隔，因此 100％使用 CPU。
   + 之后，轮询间隔呈指数级增长。
   + 最后在 x 秒之后，如果仍有工作，则轮询会回落到很大的间隔。

   wait()以这种方式工作的原因是，有时它用于想要等待一些计算完成的场景。因此，假设计算需要很长时间，那么我们不希望过于频繁地进行轮询。在计算简单的情况下，我们仍然希望快速轮询。为了解决这两个问题，这种看似尴尬的行为就出现了。
