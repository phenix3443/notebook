# 算法面试通关 40 讲笔记

## 01 合格程序员的第一步

国内比较好的公司：

- 快手、头条、airbnb（北京）、snapchat（深圳）
- 微信、地平线及机器人、第四范式、小米、musically、face++
- BAT、微软、Google、小红书、饿了么、网易 等等
- 新美大、滴滴

电话面试编程：

- collabedit.com
- coderpad.io 感觉这个更好用，可以直接编译运行代码。

## 02 如何有效学习算法与数据结构

《异类：不一样的成功启示录》

职业训练方法：

1. 知识分解
2. 刻意练习
3. 及时反馈

切题四件套：

- 理解题目
- 可能解法
  - 对比（时间、空间复杂度）
  - 延伸
- 编写代码
- 测试用例

## 03 如何计算算法的复杂度

## 04 如何通过 LeetCode 来进行算法练习

使用 leetcode 进行编程联系。

## 05 理论讲解：数组&链表

## 06 面试题：反转单链表和联表是否有环

206

141

## 07 理论讲解：优先队列

实现方式：

- heap <https://en.wikipedia.org/wiki/Heap_(data_structure>)

## 08 面试题：判断符号是否有效

20

## 09 面试题：用队列实现栈，用栈实现队列

232

225

## 10 理论讲解：优先队列

## 11 面试题：返回数据流中中第 k 大元素

703

## 12 面试题：返回滑动窗口中的最大值

## 13 理论讲解：哈希表

## 43 理论理解：动态规划（上）

1. 递归 + 记忆化 -> 递推。
   1. 递归是一种自上而下的思考方式，递推是一直自下而上的思考方式。
   2. 记忆化是将计算过程中的状态存储下来，避免重复计算。
2. 状态定义：`states[i][...]`。 状态的定义是解决问题的核心。位置 `i` 上的状态可能有多个。
3. 状态转移方程： `states[i][...] = process(states[i-1][...],states[i-2][...],....)`。
4. 位置 i 最优子结构: `states[n][...]` 中存在符合题目要求的最优解。 `dp[i] = bestOf(states[i][...])`。
5. 题目结果 `bestOf(dp[0]..dp[n])`

以斐波拉契数列为例：
递归：自顶向下，时间复杂度 O(2^n)。

```python
def fib(n):
  if n < 1:
    return n
  return fib(n-1) + fib(n-2)
```

重复计算：`fib(n-1)` 和 `fib(n-2)` 会计算共同元素 `fib(i)`。可以画出树状图更加清晰的明白。

动态规划：复杂度降低为 O(n)。

```python
def fib(n):
  dp = [0,1]
  for i in range(2,n):
    dp.appepnd(dp[i-1] + dp[i-2])
  return dp[n-1]
```

按照解题步骤分析：

1. 定义状态，找出最优子结构。
   从递归分析需要进行“记忆化”的状态。记忆化是为了解决递归过程中位置 i 状态的重复计算问题，从递归过程可以看出：
   1. 这道题中位置 i 处的状态只有一个，因此 `states[i]` 只需要一维。
   2. 因为只有一个状态，所以 `states[i]` 就是最优子结构，也就是最优解 `dp[i]`。
2. 定义状态转义方程。
   其实就是递归公式：`states[i] = states[i-1] + states[i-2]`。
3. 找到状态初始值。

## 44 理论理解：动态规划（下）

## 45 面试题 爬楼梯

[70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

## 46 面试题 三角形的最小路径和

[120.三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

## 47 面试题 乘积最大子序列

[152.乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)
