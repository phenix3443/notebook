# -*- coding:utf-8 -*-
#+title: mysql技术内幕（第五版）
#+author:phenix3443
#+email:phenix3443+github@gmail.com

* 第 1 章 MySql 入门
  #+BEGIN_SRC sh
mysql < test.sql
  #+END_SRC

  + 条件判断
    + IF

  + 字符串函数：
    + FORMAT
    + CONCAT
    + LIKE: '_' '%'
    + REGEXP
  + 数学函数：
    + SQRT
  + 时间函数：
    + STR_TO_DATE
    + YEAR
    + MONTH
    + DAYOFMONTH
    + CURDATE
    + TIMESTAMPDIFF
    + TO_DAYS
    + DATE_ADD
    + DATE_SUB

  自定义变量：
  + select @var:=field from table where cond;
  + set @var=val
  + select @var;

  select count(*) from tb group by field WITH ROLLUP; 显示统计数据求和。类似 excel 列的汇总结果。

* 第 2 章 使用 SQL 管理数据

** 2.1 服务器的 SQL 模式

** 2.2 服务器的标识符语法和命名规则

** 2.3 SQL 语句的大小写规则
   + sql 关键字和函数名不区分大小写。
   + 数据库名、表名、视图名默认大小写取决于服务器主机上的操作系统在文件方面的规定。
   + 存储过程和事件名字不区分大小写。触发器的名字区分大小写。
   + 列名和索引名不区分大小写。

** 2.4 字符集支持

** 2.5 数据库的选择、创建、删除和更改

** 2.6 表的创建、删除、索引和更改
   =.frm= 保存表的定义。除非进行配置（innodb_file_per_table），InnoDB 引擎会把标的数据和索引存储在它的系统空间里。

   临时表在客户端回话结束后自动删除，并且每个客户端只能看到自己的临时表。

   CREATE TABLE ... SELECT 不会复制所有的列属性，比如 AUTO_INCREMENT，索引定义。

   *应该使用分区表还是手动分表？*

   primary key 和 unique 索引的区别：
   + primary key 只能有一个。
   + primary key 中的列不能包含 null 值，unique 可以。

** 2.7 获取数据库元数据

   show 语句查询多种类型的元数据。

   INFORMATION_SCHEMA 数据库查询元数据。

** 2.8 使用连接实现多表检索
   using 子句概念上类似于 on 子句，但要求被连接的列 必须同名。最佳实践：设计表的时候，相同含义的字段名称保持一致。

   左连接结果集中，对于右表中没有匹配的行，都设置为 NULL。

** 2.9 使用子查询实现多表检索
   子查询的结果有多种，测试方法也有多种：=, !=, in, not in, any, all, exists,not exists.

   相当一部分子查询可以修改为连接，连接的效率有时候会比子查询更好些。

** 2.10 使用 union 实现多表检索
   默认情况下，Union 会将结果集中的 重复行剔除。如果想保留重复的行，要使用 union all。

** 2.11 多表删除和更新

** 2.12 事务处理
   事务隔离遇到的问题：
   + 脏读：事务所做操作尚未提交，别的事务就能看到这些修改。
   + 不可重复读：同一事务使用同一条 select 语句在每次读取时得到的结果不一样。
   + 幻读行：事务中看到以前没有过得行。

   InnoDB 提供四种事务隔离级别：
   + read uncommited。：脏读，不可重复度，幻读行
   + read commited。不可重复读，幻读行。
   + repeatable Read.(默认)
   + serializable.

** 2.13 外键和引用完整性

** 2.14 使用 FULLTEXT 索引
   三种搜索类型：
   + 自然语言搜索（默认）：字符串解析成单词
   + 布尔模式搜索：包含修饰符，指定搜索要要求。
   + 查询扩展搜索：二阶段搜索，扩展大搜索范围，查找自然搜索匹配不到的行。

* 第 3 章 数据类型
** 3.1 数据值类别
   字符集和排序规则：CHARSET() COLLATION() CONVERT()

   字符串长度：CHAR_LENGTH LENGTH

   时态：DATE_FORMAT() STR_TO_DATE()

** 3.2 MySql 数据类型

   定义数据列的时候，遵循通用属性，特殊属性的顺序。

   VARCHAR(M), M 最大为 65535 个字符，因为 MySql 中，行的最大长度是 65535.

   LIKE 与 REGEXP 区别：
   + LIKE 模式只能用于匹配整个字符串。REGEXP 可以匹配 字符串的任何部分。
   + LIKE 运算符是多字节安全的。REGEXP 只能正确的处理单字节字符集。

   BLOB 最大可以到 4GB，

   AUTO_INCRMENT 应该具备 NOT NULL 属性约束，而且必需被索引。因为不可能为负数，所以最好加上 UNSIGNED，这样可以使范围扩大一倍。

   ENUM 最多能够指定 65535 成员，存储空间由成员个数确定；

   SET 最多 64 个成员，每个成员都是一个二进制位，成员的数值都是 2 的幂。二者插入合法值时都不区分大小写。

   ENUM 和 SET 类型要比其他字符串类型有着更好的处理性能，因为它们可以用数字操作替换字符串操作进行处理。


** 3.3 MySql 如何处理无效数据

** 3.4 处理序列
   LAST_INSERT_ID()只会依赖于服务器的当前会话连接所产生的 AUTO_INCREMENT 值。

   多行 INSERT 语句，LAST_INSERT_ID()只会返回第一个。

** 3.5 表达式计算和类型转换

** 3.6 选择数据类型

* 第 4 章 视图和存储程序
** 4.1 使用视图
** 4.2 使用存储程序
   + 存储函数
   + 存储过程
   + 触发器
   + 事件
** 4.3 视图和存储程序的安全性
* 第 5 章 查询优化
** 5.1 使用索引
   默认情况下，InnoDB 引擎只使用一个表空间，在这个表空间内部，管理所有 InnoDB 表的数据存储和索引存储。

   可以配置 InnoDB，让它创建的每个表都有自己的表空间，但是即便如此，给定表的数据和索引也同样保存在同一个表空间中。

   MySql 使用索引的方式有以下集几种：
   + WHERE 语句。
   + MIN(),MAX()
   + ORDER BY 和 GROUP BY 子句
   + 直接读取索引查询所要求的所有信息。

   索引代价:
   + 增加了磁盘空间。
   + 降低了索引列插入、删除和更新值的速度。

   如何确定索引列：
   + 为用于搜索、排序或者分组的列创建索引，而用于输出的列则不用创建索引。
   + 认真考虑数据列计数。列基数高（重复值少）索引使用的效果越好。
   + 索引短小值
     + 短小值让比较操作更加方便，从而加快索引查找速度。
     + 短小值让索引更加短小，键缓存里的索引块可以容纳更多的值，这样内存可以容纳更多的索引快，减少 io 磁盘请求。

     InnoDB 使用的是聚簇索引，聚簇索引会把数据行和主键存储在一起（即聚集在一起）。其他的索引都是二级索引，它们把主键值和二级索引值存储在一起。
   + 索引字符串值使用前缀索引。
   + 利用最左前缀。
   + 不要建立过多的索引。
   + 让参与比较的索引类型保持匹配。
     + 散列索引。适用于完成 ~=~ 或 ~<>~ 精确匹配的操作。
     + B 树索引。适用于范围比较 =< > between= 等。
   + 利用慢查询日志找到性能低劣的查询。

** 5.2 MySql 查询优化程序
   如何优化查询：
   + 分析表：ANALYSE TABLE
   + 使用 EXPLAIN 验证优化程序的操作。
   + 在必要时给予优化程序提示或改写它。 =FORCE INDEX/USE INDEX/IGNORE INDEX/STRAIGHT_JOIN=
   + 比较拥有相同数据类型的列。
   + 让索引列在比较表达式中单独出现。
   + 不要在 LIKE 模式的开始位置使用通配符。
   + 利用优化程序的长处。
   + 测试查询的各种替代形式，并多次运行它们。
   + 避免过多是使用自动类型转换。

   如何使用 EXPLAIN 查看语句执行流程。

** 5.3 选择有利于高效查询的数据类型
   + 多用数字运算，少用字符串运算。
   + 选择够用的小类型。
   + 把数据列定义为 NOT NULL，因为查询期间，不再需要检查该列是否为 NULL
   + 整理碎片。方法：先 mysqldump 转存，然后重建。
   + 把数据压缩到 BLOB 或 TEXT 列
   + 使用合成索引。
   + 避免检索很大的 BLOB 或 TEXT。
   + 把 BLOB 或 TEXT 列剥离出来形成单独的表。

** 5.4 选择有利于高效查询的表存储方式
   InnoDB 不会区别对待固定长度和可变长度列（所有行都使用一个指向列值的头指针），所以使用 char 列在本质上不会比 varchar 列更简单。二者主要的性能因素在于行占用的存储量。

** 5.5 高效加载数据
   LOAD DATA 的效率要比 INSERT 高。

   LOAD DATA 在不带 LOCAL 的情况下效率会更高。

   如果必须使用 INSERT，优先使用单条语句插入多个行的形式。

** 5.6 调度、锁定和并发

* 第 10 章 MySql 管理简介

* 第 11 章 MySql 数据目录

* 第 12 章 MySql 基本管理

* 第 13 章 安全性和访问控制

* 第 14 章 数据库维护、备份和复制
