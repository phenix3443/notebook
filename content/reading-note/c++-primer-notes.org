# -*- coding:utf-8-*-
#+TITLE: 《C++ Primer》读书笔记
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 第 1 章 开始
** 1.2
   endl 是一个被称为操纵符（manipulator）的特殊值。写入 endl 的效果是结束当前行，并将与设备相关的缓冲区中的内容刷新到设备中。

** 1.4.3
   使用 istream 对象作为条件时，其效果是检测流的状态：
   #+BEGIN_SRC c++
while(std::cin >> value) {

}
   #+END_SRC

* 第 2 章 变量和基本类型
** 2.1.1 算数类型
   可寻址的最小内存块称为“字节”，存储的基本单元称为“字”。

   C++ 标准指定了浮点数 *有效位数* 最小值，通常 float 以 1 个字（32 比特）来表示，double 以 2 个字（64 比特）表示。

   为什么整数规定的存储所用的内存，而浮点数规定的有效位数呢，这是由于二者在内存中的存储方式不同导致的。[fn:1]

   与其他整型不同，字符型分为了三种：char、signed char、unsigned char。尽管字符型有三种，但是表现形式只有两种：带符号和无符号的。类型 char 实际上会表现为哪种有编译器确定。

   执行浮点运算选择 double，因为精度更高，计算代价和 float 差不多，有的机器甚至更快。

** 2.1.2 类型转换
   自动进行类型转换。类型转换规则中需要注意的地方：
   + 浮点数赋给整数，结果仅保留浮点数的整数部分。
   + 赋值给无符号类型超过其表示范围时，结果是初始值对无符号类型表示数取模后的余数。
   + 赋值给带符号类型超过其表示范围时，结果是未定义的。
   + 带符号和无符号混用，带符号数自动转换为无符号数。 *不要混用带符号类型和无符号类型*

** 2.1.3 字面量常量
   默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的，也可能是无符号的。

   十进制字面值的类型是 int、long、long long 中能容纳其值的最小者。

   八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long、unsigned long long 中的尺寸最小者。如果放不下，报错。

   short 没有对应的字面值。

   浮点型字面值是一个 double。

   单引号括起来的是字符，双引号括起来的是字符串。

   如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分割，则它们实际上是一个整体。

** 2.2.1 变量定义
   对象是指一块能存储数据并具有某种类型的内存空间。变量是用来引用该对象的名字。

   初始化和赋值是完全不同的操作。

   当内置类型变量使用 *列表初始化* 的好处：如果使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

   定义在 *块中* 的 *内置类型或复合类型的对象* 被 *默认初始化* ，否则它们的值是 *未定义* 的。

   为了支持分离式编译，C++语言将声明和定义分开。最佳实践： *只在头文件中定义变量声明*

   声明使变量为程序所知，定义创建与名字关联的实体，也就是说定义分配了内存。

   C++ 是静态类型语言，其含义是在编译阶段检查类型。

   几种初始化方式说明：
   + 默认初始化，意味着内置类型和组合类型的对象的值是未定义的，而类类型对象使用默认构造函数进行初始化。
   + 直接初始化， =int i = 10;=
   + 构造方式初始化，使用 =()=
   + 列表初始化，使用 ={}=

** 2.2.4 作用域
   C++中大多数作用域都以花括号分割。实际上只有两种作用域：
   + 全局作用域：在整个程序的范围内都可以使用。
   + 块作用域，花括号以内的部分。

** 2.3.1 引用
   *引用不是对象，只是对象的别名* ，这是引用的本质，很多引用的特性都基于此：
   + 所以必须初始化。
   + 由于所有对引用的操作都是作用于绑定的对象本身，所以无法将引用重新绑定到别的对象。
   + 因为引用不是对象，也不能定义引用的引用。
   + 引用的类型要和与之绑定的对象类型严格匹配。
   + 引用只能绑定在对象上，不能是字面值或者某个表达式的计算结果。

   为什么需要引用？[fn:2]
   1. 引用作为变量的短名字，代码更清晰。而且指针是对象，占用内存，引用只是别名，不占用内存（标准规定）。
      #+BEGIN_SRC c++
auto& nDays =  Month[monthindex].NumberOfDays;
      #+END_SRC
      如果不这样使用，可能要使用指针或赋值给新的变量，都会有内存开销。

      目前编译器实现中，引用底层使用指针实现的，但是编译器可能对此有优化，所以有时候可以不用内存空间。

   2. 引用通常用在函数参数，或者返回值。相比指针：
      1. 写法更简单。

         第二种函数调用，单从使用就知道输入参数和输出参数。而且 input 在使用过程中，还不用加 =*= 。

      2. 比指针更安全，指针可能为空，使用需要进行判断，而引用则不需要。

   引用是如何实现的？

   应用底层使用指针实现的：


   #+BEGIN_EXAMPLE
&x=8af7c48,&y=8af7c4c,&b=8af7c48,b=1
   #+END_EXAMPLE

** 2.3.2 指针
   *指针本身是对象* 。可以不初始化，可以通过赋值重新指向别的对象。

** 2.3.3 理解复合类型的声明
   变量的定义包括 *一个基本数据类型* 和 *一组声明符* 。

   声明符由一个变量名和多个修饰符（*或&）组成。默认情况下，类型修饰符从右向左依次绑定。离变量名最近的符号对变量的类型有最直接的影响。

** 2.4 const 限定符
   const 对象必须初始化。

   默认情况下，const 对象仅在文件内有效。这是因为编译器在编译过程中把用到该变量的地方都替换成对应的值。所以必须在每个用到该变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const 对象被设定为仅在文件内有效。

   但是，有些情况下，需要在不同文件中共享同一常量，而我们不想每个文件都生成独立的变量。也就是说，希望在一个文件中定义，而在其他多个文件中声明并使用它，做法是：对于 const 变量 *不管是声明还是定义* 都使用 extern 关键字。

   为什么要在定义之前也添加 extern 关键字呢？之前不是变量定义和 extern 一起相当于 extern 无效么？其实 extern 是用来修饰 const 的，之前说过 const 变量默认值在文件中有效，加上 extern 之后，就是告诉编译器，该 const 对象也会被其他文件引用到。

   当常量引用被绑定到 *另外一种类型* 的对象上时，实际上是绑定到了另外一种类型变量转换的临时变量上。

   常量引用只是对 *引用可参与的操作* 做了限定，对引用所指的对象本身是否是常量并不做限定。

   const 修饰符可以出现的位置有那些？（变量定义，参数声明，返回值声明，const 类成员函数）
** 2.5.1 类型别名

   在使用类型别名的声明语句时，将它替换成本来的样子是一种错误的解析方法。例如：

** 2.5.2 auto 类型说明符
   编译器以引用对象的类型作为 auto 的类型。如果希望推断出的 auto 类型是引用，需要明确指出。

   auto 一般会忽略调顶层的 const。如果希望推断出的 auto 类型是顶层 const，需要明确指出。

** 2.5.3 decltype 类型指示符
   后续补充。

** 2.6.1 自定义数据结构
   C++11 新规定，可以为数据成员提供 *类内初始值* 。

* 第 3 章 字符串、向量和数组
** 3.1 命名空间的 using 声明
   头文件不应包含 using 声明。

** 3.2.2 string 对象上的操作
   stirng::size()返回的是 string::size_type 类型。

** 3.3 标准库 vector
   vector 是模板而非类型。

   vector 能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在保存引用的 vector。

** 3.3.2 向 vector 对象添加元素
   vector 对象可以高校添加元素，没必要预先指定 vector 元素的容量。

   如果循环内部包含有向 vector 对象添加元素的语句，不要使用范围 for 语句。

** 3.4.1 使用迭代器
   所有标准库容器的迭代器都定义了 ~==~ 和 ~!=~ ，但是它们中的大多数都没有定义 =<= 运算符。所以使用尽量将迭代器与 ~!=~ 一起使用。

   但凡使用迭代器的循环体，都不要有改变 vector 对象容量的操作。

* 第 4 章 表达式
** 4.8 位运算符
   位运算符如何处理运算对象的“符号位”依赖于机器，所以强烈建议仅将位运算符用于处理无符号类型。

** 4.11.3
   任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 const_cast。

   当需要把较大的算数类型赋值给较小的类型时，static_cast 很有用。

   const_cast 只能改变运算对象底层的 const。

* 第 5 章 语句
** 5.6.2 try
   编写异常安全的代码非常困难。我们必须清楚异常何时发生，异常发生后如何确保对象有效、资源无泄漏、程序处于合理状态等。

* 第 6 章 函数
** 6.1 函数基础
   编译器能以任意可行的顺序对实参求值。

** 6.1.2 函数声明
   含有函数声明的头文件应该被包含到定义函数的源文件中，编译器验证函数的声明和定义是否匹配。

** 6.5.2 内联函数和 constexpr 函数
   内联函数和 constexpr 函数可以在程序中多次定义。编译器需要展开内联函数，所以内联函数和 constexpr 函数通常定义在头文件中。

* 第 7 章 类
  类的基本思想是 *数据抽象* 和 *封装* 。数据抽象是一种依赖于 *接口* 和 *实现* 分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体已经定义类所需要的各种私有函数。（所以类的数据成员应该都是 private，对其访问应该通过 set 或者 get 函数）

** 7.1.1
   为什么执行加法和 IO 操作的函数不能是成员函数？

** 7.1.2
   定义在类内部的函数是隐式的 inline 函数。

   编译器分两步：首先编译成员声明，然后才轮到函数体。

** 7.1.4 构造函数
   构造函数不能声明成 const，当创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正获得其“常量”属性。因此，构造函数在 const 对象的构造过程中可以向其写值。

   编译器只有在发现类 *没有任何构造函数* 的情况下才会生成一个默认的构造函数。这条规则的依据是：如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。

   在什么情况下编译器不会为类合成默认构造函数？
   1. 如果类已经有任何构造函数。
   2. 如果类成员没有默认构造函数，无法初始化该成员。

   含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定一个自己的默认构造函数。

   编译器会自动合成默认构造函数，拷贝，赋值和析构函数。

   struct 和 class 只有默认访问权限的不同。

** 7.3.1 类成员再探
   只在类的外部定义的地方说明 inline。inline 成员函数应该和相应的类定义在同一个头文件中。

   multable 表明某个数据成员是可以修改的，即使在 const 成员函数中。

** 7.5.1 构造函数初始值列表
   如果没有在构造函数的初始值列表中显示初始化成员，则该成员将在构造函数体之前执行默认初始化。

   有时我们可以忽略数据成员初始化和赋值之间的差异。但 *如果成员是 const 或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类型没有定义默认构造函数时，也必须将该成员初始化。*

   成员初始化的顺序与它们在类定义中出现的顺序一致。

   C++11 支持委托构造函数。

** 7.5.4 隐式的类类型转换

   如果构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转换机制。

   使用 explicit 阻止隐式类型转换。只在类内声明时说明。

   explicit 声明的构造函数只能用于直接初始化，不能用于拷贝初始化。

** 7.6 类的静态成员

   静态成员函数不能声明为 const，因为它不与类对象绑定在一起。

   在类外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。

   静态成员不属于类对象，所以不能在类的内部定义。必须在类的外部定义和初始化每个静态成员。 *然而* ，我们可以为静态成员提供 const 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 constexpr。

* 第 8 章 IO 库
** IO 类
*** IO 对象无拷贝或赋值
    L279:我们不能对 IO 对象进行拷贝。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const。
*** 条件状态
    #+BEGIN_SRC c++ :tangle c++-primer/iostream-state.cc
#include <iostream>

int main(int argc, char *argv[])
{
	std::cout << std::cout.bad() << std::endl;

    return 0;
}

    #+END_SRC
** 文件输入输出

** string 流
* 第 9 章 顺序容器
** 9.2.3 begin 和 end 成员
   当 auto 和 begin 或 end 结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。
   #+BEGIN_SRC c++
auto it7 = a.begin(); //仅当a是const时， it7是const_iterator
auto it8 = a.cbegin(); //it8是const_iterator
   #+END_SRC
** 9.2.4 容器的定义和初始化
   array 元素会默认初始化。

   assign 不适合关联容器和 array。
** 9.2.5 赋值和 swap
   除 array 外，swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。

** 9.3.1 向顺序容器添加元素
   容器元素是拷贝。

   insert 插入到迭代器指示的位置之前，并返回指向插入的第一个元素的 *迭代器* 。为什么是前插？因为迭代器可能指向容器尾部之后不存在元素的位置，而且在容器开始位置插入元素是很有用的功能能。

** 9.3.2 访问元素
   访问成员函数（front、back、at、[]）返回的是 *引用* 。在调用 front 和 back 之前，要保证容器非空。

** 9.3.3 删除元素
   erase（p）删除 p 所指定的元素，返回一个指向被删除元素之后元素的迭代器。

** 9.3.4 特殊的 forward_list 操作
   forward_list 添加删除元素，添加或删除的元素之前的那个元素的后继会发生变化。但是 forward_list 没办法获取一个元素的前驱。处于这个原因，在一个 forward_list 中添加和删除元素的操作是通过改变给定元素之后的元素来完成。

   所以 forward_list 没有 insert，erase 和 emplace，而是定义了 insert_after、erase_after、emplace_after。

   注意：insert_after 返回指向最后一个插入元素的迭代器。erase_after 返回一个指向被删除元素之后元素的迭代器。

   它还定义了 before_begin 的操作。

** 9.3.6 容器操作可能使迭代器失效

   对于 vector 和 string，删除元素时，尾后爹地阿奇总是会失效。

** 9.4 vector 对象是如何增长的
   调用 reserve 永远不会减少容器占用的内存空间。类似的，resize 成员函数改变容器中元素的数目，而不是容器的容量。

** 9.6 容器适配器

   默认情况下，stack 和 queue 是基于 deque 实现的，priority_queue 是基于 vector 实现的。

* 第 10 章 泛型算法
** 10.1 概述
   算法永远不会执行容器的操作，也就是说算法不会改变底层容器的大小。
** 10.2 初识泛型算法
   理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素。
** 10.3.2 lambda 表达式
   lambda 表达式具有如下形式：
   #+BEGIN_SRC c++
[capture list] (parameter list) -> return type {function body}
   #+END_SRC

** 10.3.3 lambda 捕获和返回
   当定一个一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型。

   值捕获：被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。

   引用捕获：

   隐式捕获：

** 10.3.4 参数绑定
   待添加
** 10.4 再探迭代器
   待添加
** 10.5 泛型算法结构
   待添加

* 第 11 章 关联容器
** 使用关联容器
** 关联容器概述
   L376:关联容器不支持顺序容器的位置相关的操作，因为关联容器是根据关键字存储的。
*** 定义关联容器
*** 关键字类型的要求
    L378:有序容器关键字类型必须定义元素比较方法。
    #+BEGIN_SRC c++
multiset<key,decltype(compare)*> s; //注意不要忘记*指定函数指针
    #+END_SRC
** 关联容器操作
*** 关联容器和迭代器
    L383：我们通过不对关联容器使用泛型算法。关键是 const 这一特性意味着不能将关联容器传递给修改或重排容器元素的算法。

    L383:对关联容器使用泛型搜索算法（快排）是一个坏主意，应该使用关联容器的 find 成员函数。

    L383：在实际编程中，如果真要对一个关联容器使用算法，它经常作为一个源序列或者目的位置。copy 算法。
*** 添加元素
    L384：对于不包含重复关键字的容器，insert 函数返回的是一个 pair，first 是一个指向给定关键字元素的迭代器，second 成员是 bool，表明插入成功还是已在容器中。
*** 删除元素
    #+BEGIN_SRC c++
c.erase(k) //返回删除元素的数量
c.erase(p) c.erase(b,e) //删除指定（范围）元素，返回最后一个指向最后一个被删除元素之后位置的迭代器
    #+END_SRC
*** map 的下标操作
    L387:与其他下标运算符不同的是，如果关键字并不在 map 中，会为它创建一个元素并插入到 map 中。 *但是 at 函数不会执行插入操作，而是抛出 out_of_range*的异常。
    注意 map 下标操作符返回 ~mapped_type~ ，迭代器解引用返回 ~value_type~ 。
*** 访问元素
    #+BEGIN_SRC c++
c.find(k)
c.cout(k)
c.lower_bound(k)
c.upper_bound(k)
c.equal_range(k)
    #+END_SRC
** 无序容器
   #+CAPTION: 使用无序容器统计出现次数最多的K个数。
   #+BEGIN_SRC c++

   #+END_SRC

   #+CAPTION:求两个字符串数组的交集
   #+BEGIN_SRC c++

   #+END_SRC
   L395:无序容器的性能依赖与哈希函数的质量和桶的数量和大小。
* 第 12 章 动态内存
** 12.1 动态内存与智能指针
   shared_ptr 允许多个指针指向同一个对象。

   unique_ptr 独占所指向对象。

   weak_ptr 是一种弱引用，指向 shared_ptr 所管理的对象。

   最安全的分配和使用动态内存的方法是调用一个名为 make_shared 的标准函数。如果不传递任何参数，就进行值初始化。

   shared_ptr 在无用之后仍然保留的一种可能情况是：讲 shared_ptr 存放在一个容器中，随后重排了容器，从而不需要某些元素。在这种情况下，应该确保使用 erase 删除那些不再需要的 shared_ptr 元素。

   使用动态内存处于三种原因：
   + 程序不知道自己需要多少对象。（如容器类）
   + 程序不知道所需对象的类型。
   + 程序需要在多个对象间共享数据。

   智能指针是否可以完全替代 new 和 delete？

** 12.1.2 直接管理内存
   如果 new 不能分配所要求的内存空间，它会抛出一个类型胃 bad_alloc 的异常，使用以定位 new 阻止抛出异常：
   #+BEGIN_SRC c++
auto ptr = new (nothrow) int; // 付过分配失败，返回空指针。
   #+END_SRC

   定位 new 允许向 new 传递额外的参数。
** 12.1.3 shared_ptr 和 new
   内置指针必须通过直接初始化才能转换成智能指针，不能通过隐式转换进行。而且内置指针必须指向动态内存。

   不要混用普通指针和智能指针。
** 12.1.5 unique_ptr
   unique_ptr 不能拷贝，但是可以拷贝货值一个将要被销毁的 uniqe_ptr，所以 unique_ptr 可以作为参数或返回值传递。
** 12.1.6 weak_ptr

** 12.2 动态数组

* 第 13 章 拷贝控制
  如果一个类没有定义相应的拷贝控制成员，编译器会自动为它们定义相应的操作：拷贝构造函数，拷贝赋值操作符，移动构造函数，移动赋值操作符，析构函数。
** 13.3
   如果一个类的第一个参数是自身类型的 *引用* ，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
** 13.1.1
   拷贝构造函数发生在：
   + 使用 = 定义变量时。
   + 将一个对象作为实参传递给一个非引用类型的形参。
   + 从一个返回类型为非引用的函数返回一个对象。
   + 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
** 13.1.2
   标准库通常要求保存在容器中的类型要具有赋值运算符，且返回值是左侧运算对象的引用。

   在一个析构函数中，首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁。

** 13.1.4
   程序的拷贝控制函数（拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数）应该看作一个整体：只要需要定义其中一个，其他函数也需要定义。

** 13.2.1
   赋值运算符通常组合了析构函数和构造函数的操作，应该是异常安全的。同时还要考虑到自赋值的情况。

** 13.6 对象移动
   对象移动的用处：
   + 节省拷贝导致的内存消耗。
   + 有些类不能拷贝，但是可以移动。例如 IO 类或者 unique_ptr;


** 13.6.1 右值引用
   右值引用要么字面常量，要么是将要销毁的对象。

   变量是左值，所以不能将右值引用绑定到一个右值引用的变量上。

   不能对移动后源对象做任何假设，这是为什么？

   可以销毁一个移后源对象，也可以赋予它值，但不能使用一个移后源对象的值。 这是为什么？

   一旦移动完成，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象。

   noexcept 指明函数不会抛出异常。如果不指定，在内存分配过程中就会使用拷贝构造函数而不是移动构造函数。

   移动操作完成后，源对象会被销毁。必须保证移后源对象进入一个可析构的状态。

   此外，移动操作还必须保证对象仍然是有效的。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们不应该依赖于移后源对象中的数据。

   如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动操作符了。

   只有当一个类没有定义自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动操作符。

   如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝函数和拷贝赋值运算符会被定义为删除的。所以，定义类移动构造函数或移动赋值操作符的类也必须定义自己的拷贝操作符。否则，这些成员默认的被定义为删除的。

* 第 14 章 重载运算与类型转换
** 基本概念
** 输入和输出运算符
** 算术和关系运算符
** 赋值运算符
** 下标运算符
** 递增和递减运算符
** 成员访问运算符
** 函数调用运算符
** 重载、类型转换与运算符
* 第 15 章 面向对象程序设计
** 15.1
   面向对象程序设计的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，可以将类的接口于实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以同意的方式使用它们的对象。

   基类将希望派生类各自定义的函数声明为虚函数。

   派生类必须在其内部对 *所有重新定义* 的虚函数进行 *声明* 。

   当使用基类的引用（指针）调用一个虚函数时将发生动态绑定。

** 15.2.1

   任何构造函数之外的非静态函数都可以是虚函数。

   构造函数为什么不能是虚函数？[fn:3]

   静态函数为什么不能是虚函数？

   基类的虚函数在派生类中隐式的也是虚函数。

   为什么会有 protect 关键字？因为派生类 *可以继承* 定义在基类中的成员，但是派生类 *不一定有权访问* 从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问共有成员，但是不能访问私有成员。但是有时候希望能够有些成员派生类可以访问，但外部代码不能访问，所以才有 protect。

** 15.2.2
   派生类访问说明符是控制派生类从基类继承来的成员是否对 *派生类的用户* 可见。

   派生类必须使用基类的构造函数来初始化它的基类部分。

   派生类可以访问基类的公有成员和保护成员。

   final 关键字用于防止继承发生。

** 15.3
   当且仅当通过基类的指针或引用调用虚函数时会发生动态绑定。

   引用和指针的静态类型与动态类型不同这一事实正是 C++语言支持多态性的根本所在。

   使用 override 关键字表明派生类覆盖了基类函数。

   虚函数调用的默认实参由本次调用的静态类型决定，所以虚函数如果使用默认实参，最好基类和派生类中的默认实参保持一致。（为什么？如果不一致，派生列中的函数将隐藏基类的中同名函数，就无法通过类的引用或指针调用派生类的虚函数）

   使用作用域操作符强制调用指定版本的虚函数。

** 15.4 抽象基类

   可以为纯虚函数提供定义，不过函数体必须定义在类的外部。

** 15.5 访问控制和继承
   派生类的成员或友元只能通过 *派生类对象* 来访问基类的受保护成员。派生类对于一个 *基类对象* 中的受保护成员没有任何访问特权。否则，只需要定义基类的使用者只需要定义派生类，就可以绕过 protect 关键字。

   对基类成员的访问权限只与基类中的访问说明符有关。

   派生访问说明符的目的是控制 *派生类用户* （包括派生类的派生类）对于基类成员的访问。

   友元关系既不能传递，也不能继承。

   使用 using 语句修改个别成员的可访问性。

   struct 和 class 关键字唯一的差别就是 默认成员访问说明符以及默认派生访问说明符，除此之外，别无不同。

** 15.6 继承中的作用域

   对象、指针、引用的静态类型决定了对象的哪些成员是可见的。

   如果派生类的成员与基类成员的某个成员同名，则派生类将 *在其作用域内* 隐藏该基类成员，即使二者的形参列表不同。

   使用 using 声明语句，把函数的所有重载实例添加派生类的作用域中。
** 15.7.1 虚析构函数
   虚析构函数将阻止合成而移动操作。

** 15.7.2 合成拷贝控制与继承
   派生类析构函数除了销毁自身成员，还销毁派生类的直接基类。

** 15.7.3
   默认情况下，基类默认构造函数初始化派生类的基类部分。如果想要 *拷贝（或移动）* 基类部分，则必须在派生类的构造函数列表中显式使用基类的拷贝（或移动）构造函数。

   如果构造函数或析构函数调用了某个虚函数，则应该是执行与构造函数或析构函数所属类型相对应的虚函数版本。

** 15.7.4 继承的构造函数
   当 using 作用于构造函数时，using 声明语句将令比哪一期产生代码。对于积累的构造函数，编译器都生成一个与之对应的派生类构造函数。
* 第 16 章 模板与泛型编程
* 第 17 章 标准库特殊设施
* 第 18 章 用于大型程序的工具
** 异常处理
** 命名空间
   #+BEGIN_SRC c++ :tangle c++-primer/test_namespace.cc
      #include <gtest\gtest.h>

      //测试命名空间
      namespace phenix3443 {
          namespace NS {
              class Quote { };
              void display (Quote&) { std::cout << "function in ns namespace" << std::endl; }
          }
          TEST (TestNameSpace, TestFunctionFind) {
              //测试嵌套命名空间中函数蚕食是类对象的查找过程。
              display (NS::Quote ());
          }

          namespace A { int i = 0, j = 0; }
          int f () {
              int i = 1;
              using namespace A;
              std::cout << "f() i = " << i << std::endl;
              return i;
          }
          int g () {
              using A::i;
              std::cout << "g() i = " << i << std::endl;
              return i;
          }
          TEST (TestNameSpace, TestUsing) {
              //测试using声明和using指示作用域的差别
              EXPECT_EQ (1, f ());
              EXPECT_EQ (0, g ());
          }
      }
   #+END_SRC
** 18.3.1 多重继承
   基类的构造顺序与派生类列表中基类的出现顺序一直，而与派生类构造函数初始值列表中基类的顺序无关。
** 18.3.2
** 18.3.3 多重继承下的类作用域
   在多重继承的情况下，相同的查找过程在所有直接基类中 *同时进行* 。如果名字在多个基类中被找到，则对该名字的使用具有二异性。
** 18.3.4 虚继承
   通过虚继承，解决派生类的继承链上有一个基类的多子对象的问题。其中共享的基类对象被称为虚基类。

   如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以访问这个被覆盖的成员。但是如果成员被多于一个基类覆盖，则一般情况下，派生类必须为该成员自定义个一个新的版本。

** 15.3.5 构造函数与虚继承
   虚基类是由最低层的派生类初始化的：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照基类在派生列表中出现的次序一次对其进行初始化。

   一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向依次构造。
* 第 19 章 特殊工具与技术
** 控制内存分配
*** 定位 new 修改内存数据
    #+BEGIN_SRC c++ :tangle interview-code/test_new.cc
      #include <iostream>
      #include <gtest\gtest.h>

      //测试new和delete
      namespace phenix3443 {
          TEST (NewDelete, PlaceNew) {
              //测试定位new修改制定内存数据
              int a = 10;
              int* ps = new(&a) int (20);
              EXPECT_EQ (20, a);
          }
      }
    #+END_SRC
** 运行时类型识别
   #+BEGIN_SRC c++ :tangle c++-primer/test_RTTI.cc
      #include <iostream>
      #include <gtest\gtest.h>

      //测试RTTI,通过RTTI如何定义类的相等操作。
      namespace phenix3443 {
          class Base {
          public:
              Base (int i = 0) :b_ (i) { }
          protected:
              virtual bool Equal (Base& rsh) { return b_ == rsh.b_; }
          private:
              int b_;

              friend bool operator== (Base& a, Base& b);
          };
          class Derived : public Base {
          public:
              Derived (int j=1) :d_ (j) { }
          protected:
              virtual bool Equal (Base& rsh) {
                  Derived& tmp = dynamic_cast<Derived&>(rsh);
                  return d_ == tmp.d_;
              }
          private:
              int d_;
          };
          bool operator==(Base& a, Base& b) {
              return (typeid(a) == typeid(b) && a.Equal (b));
          }

          TEST (TestRTTI, ClassEqual) {
              Base b;
              Derived d1, d2;
              std::cout << "Class Base's name is " << typeid(b).name() << std::endl;
              std::cout << "Class Derive's name is " << typeid(d1).name() << std::endl;
              EXPECT_TRUE (typeid(b).before (typeid(d1)));
              EXPECT_FALSE (b == d1);
              EXPECT_TRUE(d1 == d2);
              Base& br = d1;
              EXPECT_TRUE (br == d1);
          }
      }
   #+END_SRC
** 枚举类型
** 类成员指针
   #+BEGIN_SRC c++ :tangle c++-primer/class_mem_point.cc
      //测试函数成员指针
      namespace phenix3443 {
          class Screen {
          public:
              Screen () { }
              Screen (const std::initializer_list<std::string>& il) :content_ (il) { }
              char get () const {
                  return content_[cursor_[0]][cursor_[1]];
              }
              Screen& Home () {
                  cursor_ = { 0,0 };
                  return *this;
              }
              Screen& End () {
                  cursor_ = { content_.size () - 1,content_.back ().size () - 1 };
                  return *this;
              }
              Screen& Forward () {
                  if ( cursor_[1] < content_[cursor_[0]].size () - 1 ) {
                      ++cursor_[1];
                  }
                  else {
                      if ( cursor_[0] < content_.size () - 1 ) {
                          ++cursor_[0];
                          cursor_[1] = 0;
                      }
                  }
                  return *this;
              }
              Screen& Back () {
                  if ( cursor_[1] > 0 ) {
                      --cursor_[1];
                  }
                  else {
                      if ( cursor_[0] > 0 ) {
                          --cursor_[0];
                          cursor_[1] = content_[cursor_[0]].size () - 1;
                      }
                  }
                  return *this;
              }
              enum Direction { HOME, FORWARD, BACK, END };
              using Action = Screen& (Screen::*)();
              Screen& Move (Direction d) {
                  return (this->*menu_[d])();
              }
          private:
              std::vector<std::string> content_;
              std::array<size_t, 2> cursor_ = { 0,0 };
              static Action menu_[];
          };
          Screen::Action Screen::menu_[] = { &Screen::Home,&Screen::Forward,&Screen::Back,&Screen::End };

          TEST (ClassMemPoint, ScreenTest) {
              Screen text = { "first","second","third" };
              EXPECT_EQ ('f', text.get ());
              text.Move (Screen::FORWARD);
              EXPECT_EQ ('i', text.get ());
          }
      }
   #+END_SRC
** 嵌套类
** union
** 局部类
** 固有的不可移植的特性
* Footnotes

[fn:1] [[http://coolshell.cn/articles/7459.html][Huffman 编码压缩算法]]

[fn:1] [[http://blog.csdn.net/chenyiming_1990/article/details/9933109][C语言浮点数解惑]]

[fn:2] [[https://www.zhihu.com/question/34267829][C++中引用有什么用]]

[fn:3] https://www.zhihu.com/question/35632207
