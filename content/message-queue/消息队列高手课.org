# -*- coding:utf-8-*-
#+TITLE: 消息队列高手课
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 开篇词
  消息队列涉及的底层技术：
  + 高性能通信
  + 序列化和反序列化
  + 分布式事务
  + 一致性协议
  + 高并发（异步编程模型）
  + 数据压缩
  + 内存管理
  + 文件与高性能 IO
  + 高可用分布式系统

  常见的消息队列：
  + ActiveMQ
  + RabbitMQ
  + RocketMQ
  + Kafka
  + Pulsar
  + NSQ

* 怎样学好这门课

* 为什么需要消息队列
  消息队列的使用场景：
  + 异步处理
  + 流量控制
  + 服务解耦

  消息队列的局限：
  + 引入消息队列带来延迟问题。
  + 增加系统的复杂度。
  + 可能产生数据不一致问题。

* 该如何选择消息队列
  标准：
  + 开源产品
  + 有社区
  + 有生态

  支持特性：
  + 消息可靠传递
  + 支持集群
  + 性能

  一线产品对比：
  + RabbitMQ
    + 优点：轻量级，易于部署和使用，支持的客户端多
    + 缺点：
      + 消息堆积不友好，
      + 性能差，几万-十几万
      + 编程语言是 Erlang

  + RocketMQ
    + 优点：
      + 没有短板，
      + 响应时延短，大多数情况下可以做到毫秒级响应。
      + 每秒几十万。

  + Kafka
    + 生态好
    + 大量使用批量和异步的思想，获得超高的性能，这也导致同步消息响应时延比较高，不太适合处理在线业务场景。

  二线产品对比：
  + ActiveMQ
    + 太古老了，不推荐使用。

  + ZeroMQ
    + 本质上不是一个消息队列。

  + Pulsar
    + 采用存储和计算分离的设计。可能是将来的发展方向。

  + NSQ

* 消息模型
  术语：
  + 主题（Topic）：服务端存放消息的容器。
  + 队列（Queue）
  + 分区（Partition）
  + 生产者、订阅者

  模型：
  + 队列：
    + 代表：RabbitMQ
    + 弊端：多个消费者需要建立多个消息队列。

  + 发布/订阅
    + 代表：RocketMQ 等大多数
    + 优点：消息可以被多个消费者消费。

  RocketMQ
  + 主题
  + 队列
    + 每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。
    + RocketMQ 只在队列上保证消息的有序性，主题层面（队列间）无法保证消息的严格有序。
  + 订阅者
    + 订阅者以消费组的形式存在，每个消费组都消费主题中的一份完整的消息。消费组之间的消费进度不受影响：同一消息可以 被不同的消费组消费。
    + 消费组内有多个消费者，消费者之间消费是竞争关系，组内同一消息只能被一个消费者消费。
    + 消费组内的多个消费者之间是竞争关系。

* 如何利用事务消息实现分布式事务
  事务：原子性、一致性、隔离性、持久性（ACID）

  常见的分布式事务实现：
  + 2PC（two-phase Commit）,二阶段提交
  + TCC（Try-Confim-Cacnel）
  + 事务消息：
    + 使用场景：异步更新数据，对数据实时性要求不太高。

  RocketMQ 如何实现分布式事务，以及其中的事务反查机制。

* 如何确保消息不会丢失
  检测消息是否丢失的方法：检测消息的有序性。
  消息可能丢失的三个阶段：
  + 生产：收到 broker 返回的响应，正确处理返回值和异常。
  + 存储：正确的配置 broker 参数。
  + 消费：执行完所有业务以后在发送响应消息。

* 如何处理消费过程中的重复消息
  MQTT 协议中三种消息传递时能够提供的服务质量标准：
  + At Most Once
  + At Least Once
  + Exactly Once

  解决消息重复问题：
  + 将业务逻辑转化为幂等消费，At Least Once + 幂等消费 = Exactly Once
    + 利用数据库的唯一性约束实现幂等。
    + 为更新的数据设置前置条件。
  + 记录并检查操作。对每个操作设定 uuid。

* 消息积压了该如何处理
  + 生产端：一般是业务逻辑问题。
  + 消费端：
    + 保证消费端的消费性能高于生产端的发送性能，这样的系统才能健康持续运行。
    + 在扩充消费端实例数量的同事，必须同步扩容主题的分区（也叫队列）数量，确保消费端的实例数和分去数是相等的。因为每个分区只能支持单个消费者。

* 答疑解惑：网关如何接收服务端的秒杀结果

* 学习开源代码该如何入手

* 如何使用异步设计提升系统性能

* 如何实现高性能的异步网络传输

* 序列化和反序列化：如何通过网络传输结构化的数据

* 传输协议：应用程序之间对话的语言

* 内存管理：如何避免内存溢出和频繁的垃圾回收

* JMQ 的 Broker 如何异步处理消息

* Kafka 如何实现高性能 IO

* 缓存策略：如何私用缓存减少磁盘 IO

* 如何使用硬件同步源于（CAS）替代锁

* 数据压缩：时间换空间的游戏

* RocketMQ Producer 源码分析：消息生产的实现过程

* Kafka Consumer 源码分析：消息消费的实现过程

* Kafka 和 RocketMQ 的消息复制实现的差异点在哪

* Kafka 的协调服务 ZooKeeper：实现分布式系统的瑞士军刀

* RocketMQ 和 Kafka 如何实现事务

* MQTT 协议：如何支持海量的在线 IoT 设备

* Pulsar 的存储计算分离设计：全新的消息队列设计思路

* 答疑解惑：我的 100 元去哪里了
