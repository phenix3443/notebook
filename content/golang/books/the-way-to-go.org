# -*- coding:utf-8; -*-
#+TITLE: the way to go
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com
#+STARTUP: overview

* 第二部分：语言的核心结构与技术
** 第四章 基本结构和数据类型
*** 4.5 基本类型和运算符
	+ int 类型是计算最快的一种类型。为什么？
    + 字符 byte 是 uint8 的别名。
    + unicode(utf-8)字符类型是 rune，是 int32 的别名。
	+ 带有 ++ 和 -- 的只能作为语句，而非表达式。不能用在 for 的第三部分。

*** 4.6 字符串
	+ 字符串是是 UTF-8 字符序列
    + 字符串是字节的定长数组。
    + 解释字符串和非解释字符串
    + 字符串拼接的方法及其效率。

*** 4.7 strings 和 strconv 包

*** 4.8 时间和日期

*** 4.9 指针
    Go 语言可以隐藏简介引用。

** 第五章 控制结构
*** 5.1 if-else 循环
	+ if 可以包含一个初始化语句，但是初始化语句中定义的变量作用域只限于 if 语句中。

*** 5.2 测试多返回值函数的错误

*** 5.3 switch 结构
    + 逗号分割多个测试值 =case var1,var2,var3=
    + 也可以没有测试条件，等效于多个 if-else 语句。
    + 测试条件包含初始化语句。

*** 5.4 for 结构
    + golang 循环只有 for 语句。
    + for 当做 while 使用，没有第一和第三部分。
    + for-range，其中 value 是集合中对应元素的值拷贝。

*** 5.5 break 与 continue

*** 5.6 标签与 goto

** 第六章 函数
*** 6.1 介绍

*** 6.2 函数参数与返回值
    应该尽量使用命名返回值。

*** 6.3 传递变长参数
    变长参数放在 slice 中。

*** 6.4 defer 和追踪
	+ 注意 defer 与 return 的坑。

*** 6.5 内置函数
    new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。

    new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。

*** 6.6 递归函数

*** 6.7 将函数作为参数

*** 6.8 闭包

*** 6.9 应用闭包：将函数作为返回值

*** 6.10 使用闭包调试

*** 6.11 计算函数执行时间

*** 6.12 通过内存缓存提升性能

** 第七章 数组与切片
*** 7.1 声明与初始化
	数组长度也是数组类型的一部分。

*** 7.2 切片
    make()创建一个切片，同时创建好相关数组。

    make 和 new 看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。
    + new(T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为*T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 &T{}。
    + make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel（参见第 8 章，第 13 章）。

*** 7.3 for-range 结构

*** 7.4 切片重组

*** 7.5 切片的复制与追加
	+ 切片如何扩展成列表？

*** 7.6 字符串、数组和切片的应用
	+ 在内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。
	+ append 的一些有用的用法：
	  1. 删除位于索引 i 的元素：a = append(a[:i], a[i+1:]...)
	  2. 取出位于切片 a 最末尾的元素 x：x, a = a[len(a)-1], a[:len(a)-1]
** 第八章 map
*** 8.1 声明、初始化和 make
*** 8.2 测试键值对是否存在及删除元素
*** 8.3 for-range 的配套用法
*** 8.4 map 类型的切片
*** 8.5 map 的排序
*** 8.6 将 map 的键值对调

** 第九章 包
*** 9.1 标准库概述
*** 9.2 regexp 包
*** 9.3 锁和 sync 包
*** 9.4 精密计算和 big 包
*** 9.5 自定义包和可见性
	+ import . "path/to/package"
	+ import _ "path/to/package"
*** 9.6 为自定义包使用 godoc
*** 9.7 使用 go install 安装自定义包
*** 9.8 自定义包的目录结构、go install 和 go test
*** 9.9 通过 git 打包和安装
*** 9.10 go 的外部包和项目
*** 9.11 在 go 程序中使用外部库
** 第十章 结构与方法
*** 10.1 结构体定义
*** 10.2 使用工厂方法创建结构体实例
*** 10.3 使用自定义包中的结构体
*** 10.4 带标签的结构体
*** 10.5 匿名字段和内嵌结构体
*** 10.6 方法
	+ 如果方法不需要使用 recv 的值，可以用 _ 替换它，比如：
	  #+BEGIN_SRC go
func (_ receiver_type) methodName(parameter_list) (return_value_list) { ... }
	  #+END_SRC
	  和类方法类似。
	+ 在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现。

*** 10.7 类型的 string（）方法和格式化描述符
*** 10.8 垃圾回收和 setFinalizer
** 第十一章 接口与反射
*** 11.1 接口是什么
*** 11.2 接口嵌套接口
*** 11.3 类型断言
*** 11.4 类型判断
	+ type-switch
*** 11.5 测试值是否实现了某个借口
*** 11.6 使用方法集与接口
	+ 接口变量中存储的具体值是不可寻址的。这句话是什么意思？
	+ 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集。
*** 11.7 例子 1
*** 11.8 例子 2
*** 11.9 空接口
*** 11.10 反射包
*** 11.11 Printf 与反射
*** 11.12 接口与动态类型
*** 11.13 总结：go 中的面向对象
*** 11.14 结构体、集合和高阶函数
* 第三部分 Go 高级编程
** 第十二章 读写数据

** 第十三章 错误处理与测试

** 第十四章 协程与通道

** 第十五章 网络、模板与网页应用

* 第四部分 实际应用

** 第十六章 常见的陷阱与错误

** 第十七章 模式

** 第十八章 处于性能考虑的实用代码片段
