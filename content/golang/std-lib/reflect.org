# -*- coding:utf-8-*-
#+TITLE: refect
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com
* 概述
  [[https://golang.org/pkg/reflect/][reflect]] 包实现了运行时反射，从而允许程序处理任意类型的对象。典型的用法是使用静态类型 =interface{}= 获取一个值，并通过调用 =TypeOf= 函数来提取其动态类型信息，该函数返回一个 =Type= 结构。

  =ValueOf= 函数会返回一个代表运行时数据的 Value。  =Zero= 函数返回参数类型对应的零值。

* 使用
** Copy
   #+BEGIN_SRC go
func Copy(dst, src Value) int
   #+END_SRC

   Copy 将 src 的内容复制到 dst 中，直到填满 dst 或用尽 src。它返回复制的元素数。 Dst 和 src 每个都必须具有种类 Slice 或 Array，并且 dst 和 src 必须具有相同的元素类型。

   作为一种特殊情况，如果 dst 的元素类型为 Uint8，则 src 可以具有 String 类型。

** DeepEqual

   #+BEGIN_SRC go
func DeepEqual(x, y interface{}) bool
   #+END_SRC

   DeepEqual 报告 x 和 y 是否慢如如下定义的“深度相等”。如果满足以下情况之一，则两个相同类型的值将深度相等。不同类型的值永远不会深度相等。

   当数组的对应元素深度相等时，数组值深度相等。

   如果结构的值对应的字段（导出的和未导出的）深度相等，则该值深度相等。

   如果连个函数都为 nil，它们深度相等。否则，它们就不会深度相等。

   如果接口值具有深度相等的具体值，则它们是深度相等的。

   当满足以下所有条件时，映射值深度相等：它们都为 nil 或都不为 nil，它们的长度相同，并且它们是相同的映射对象或它们的对应键（使用 Go 相等匹配）映射到相等的值。

   如果指针值使用 Go's ~==~ 运算符相等，或者它们指向深度相等的值，则它们的深度相等。

   当满足以下所有条件时，slice 值将深度相等：它们均为 nil 或均为非 nil，它们具有相同的长度，并且它们指向同一基础数组的相同初始条目（即 ~＆x[0]==＆y[0]~ ）或它们相应的元素（最大长度）相等。请注意，非 nil 空片和 nil 片（例如 ~[]byte{} and []byte(nil))~ ）并不深度相等。

   如果使用 Go 的 ~==~ 运算符，其他值（数字，布尔值，字符串和通道）相等将深度相等。

   通常，DeepEqual 是 Go 的 ~==~ 运算符的递归封装。但是二者有所不同。具体来说，一些值可能与自身不相等，可能是因为值属于 func 类型（通常无法比较）或因为它是浮点 NaN 值（在浮点比较中不等于其自身），或者因为它是包含此类值的数组，结构或接口。另一方面，指针值即使指向或包含此类有问题的值也始终等于其自身，因为它们使用 Go 的 ~==~ 运算符进行相等比较，而这足以使深度相等，而与内容无关。定义了 DeepEqual，以便对切片和 map 应用相同的快捷方式：如果 x 和 y 是相同的切片或相同的 map，则无论内容如何，​​​​它们都非常相等。

   当 DeepEqual 遍历数据值时，可能会发现一个循环。 DeepEqual 在第二次及以后比较两个之前比较过的指针值时，会将这些值视为相等，而不是检查它们指向的值。这样可以确保 DeepEqual 终止。
