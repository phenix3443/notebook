# -*- coding:utf-8 -*-
#+title:Python 学习手册（第四版）读书笔记
#+author:刘尚亮
#+email:phenix3443@gmail.com

* 第一部分 使用入门

* 第二部分 类型和运算
** 第 4 章 介绍 Python 对象类型
   + 运行的表达式语法决定了创建和使用的对象的类型。（C 中是由变量声明决定的）
   + 每一个对象都有不可变性或者可变性。核心类型中，数字、字符串、和元组是不可变的，列表和字典是可变的。

   + 字典
     + 列表解析和相关的函数编程工具通常比 for 循环快（也许快了两倍）：这是对大数据集合的应用程序由重大影响的特性之一。
     + 判断键是否存在：
       + if/else 表达式

** 第 5 章 数字
   + 转换函数：0[x|X]、0[o|O]、0[b|B]、int(str, base)
   + (...)语法可以用于生成器表达式，生成器 表达式是产生所需结果的列表解析的一种形式，而不是构建一个最终的列表。
   + 比较操作符可以连续使用。
   + 真除法、Floor 除法和截除法的区别。

** 第 6 章 动态类型简介
   + 动态类型以及多态性是 Python 语言灵活性的根源。
   + 每个对象都有两个标准的头部信息：类型标志符和引用计数器。

** 第 7 章 字符串
   + 可以使用负数作为分片时候的步进，实际效果就是将序列进行反转。
   + 正式的来说，python 中由三个主要类型（以及操作）的分类：数字（整数、浮点数、二进制等），序列（字符串、列表、元组），映射（字典）。

** 第 8 章 列表与字典
   + 字典
     + python3 中的字典变化。

** 第 9 章 元组、文件及其他
   + 无条件值的分片以及字典的 copy 方法只能做顶层复制。
   + python 的比较总是检查对象的所有部分，直到可以得出结果位置。
   + 类型本身也是对象类型。

* 第三部分 语法和句法
** 第 10 章 Python 语句简介
   + 终止行就是终止语句。
     + 特例：某行多个语句使用分号分开，但是只能把简单语句放在一起。
     + 语句跨行：只要使用一对括号把语句括起来就可以。

** 第 11 章 赋值、表达式和打印
   + 赋值语句形式：
     + 基本形式
     + 元组赋值运算（位置性）
     + 列表赋值运算（位置性）

     从内部实现上来看，元组和列表赋值运算 Python 会先在右边制作元素的元组。

     + 序列赋值运算（通用性）
       + 任何变量名的序列都可以赋值给任何值的序列，只要两边数目相同即可。
       + 元组和列表赋值是序列赋值的特殊形式。
       + 分解赋值语句也是一种交换两个变量的值，却不需要自行创建临时变量的方式。

     + 扩展的序列解包（Python3.0）
       + 这为手动分片操作的结果赋值提供了一种简单的替代手段。
       + 这和分片内在的相似，但是不完全相同。一个序列解包赋值总是返回多个匹配项的一个列表，而分片把相同类型的一个序列作为分片的对象返回。
       + 如果有多个带星号的名称，或者如果值少了而没有带星号的名称，以及如果带星号的名称自身没有编写到一个列表中，都将会引发错误。

   + 命名惯例
     + 以单一下划线开头的变量名（ ~_X~ ）不会被 from module import * 语句导入。
     + 前后都有下划线的变量名（ ~_X_~ ）是系统定义的变量名，对解释器有特殊意义。
     + 以两下划线开头、但结尾没有两个下划线的变量名（ ~__X~ ）是类的本地变量。
     + 通过交互模式运行时，只有单个下划线的变量名（ ~_~ ）会保存最后表达式的结果。

** 第 12 章 if 测试和语法规则
   + if 使用 elif 做分支。
   + 多路分支
     + 写成一系列的 if/elif 测试，
     + 或者对字典进行索引或搜索列表。
   + 真值测试：
     + 任何非零数字或非空对象都为真。
     + 数字零、空对象以及特殊对象 None 都被认作是假。
     + 比较和相等测试都会递归的应用在数据结构中。
     + 比较和相等测试都会返回 Ture 或 False。
     + 布尔 and 和 or 运算符会返回真或假的操作对象。
   + if/else 三元表达式 A = Y if X else Z

** 第 13 章 while 和 for 循环
   + 使用 while True/if break 模拟 do/until 语句。
   + 循环 else：
     + 控制权离开循环而又没有碰到 break 语句时才会执行。
     + 和循环 else 子句结合时，break 语句通常可以忽略其他语言中所需的搜索状态标志位。
   + for 循环中的赋值可以是任何形式的赋值，包括序列赋值。
   + for line in open('test.txt'):这通常是读取文件的最佳选择，除了简单，对任意大小的文件都有效，不会一次把文件都载入内存。
   + for 比 while 容易写，执行也比较快，应该作为遍历序列首选工具。
   + zip 并行遍历，当长度不同时，zip 会以最短序列的长度为准来截断所得到的元组。
   + enumerate 产生偏移和元素。
   + while 和 for 的主要功能区别是：while 一条通用的循环语句，for 循环主要用来在一个序列中遍历各项。

** 第 14 章 迭代器和解析，第一部分
   + 列表解析是对迭代中的项应用一个表达式的 for 循环的一种近似形式。
   + 迭代工具可以用于任何可迭代的对象。
   + 当 for 循环开始时，会通过它传给 iter 内置函数，以便可从可迭代对象中获得一个迭代器，返回的对象含有需要的 next 方法。
   + 文件对象是自己的迭代器。列表以及很多其他内置对象不是自身的迭代器，因为它们支持多次打开迭代器。对这样的对象，必须调用 iter 来启动迭代。
   + 可迭代的对象一次返回一个结果，而不是一个实际的列表。
   + 可迭代对象有时候就是自己的迭代器，有时候需要调用 iter 返回迭代器。比如文件对象就是自己的迭代器，列表以及很多内置对象不是自身的迭代器。range 不是自己的迭代器。
   + 迭代器在 Python 中是以 C 语言运行的。
   + 字典有一个迭代器，每次返回一个键。
   + 列表解析与 for 不同，它产生一个新的列表对象。而且列表解析比手动的 for 循环更快。
   + 扩展的列表解析语法可以包含 if 语句过滤那些测试不为真的结果。
   + 字典的 keys、values、items 方法返回字典视图迭代器，他们一次产生一个结果项。

** 第 15 章 文档
   + #注释只能从源代码文件中看到。
   + 文档字符串最适合较大型功能的文档（模块、类、函数），#注释适合做较小功能的文档（表达式）。
   + 可以通过 PyDoc GUI 模块查看位于导入搜索路径上的用户定义模块以及动态连接的 C 程序模块。

* 第四部分 函数
** 第 16 章 函数基础
   + 可以在 if、while 等语句中定义函数。
   + 一个函数内部的任何类型的赋值都会把一个名称划定为本定的，包括 import 中的模块名称，def 中的函数名称等等。
   + 如果 lambda 或 def 在函数中定义，嵌套在一个循环中，并且嵌套的函数引用了一个上层作用域的变量，该变量被循环所改变，所有在这个循环中产生的参数将会有相同的值---在最后一次循环中完成时被引用变量的值。
** 第 17 章 作用域

** 第 18 章 参数
   + 参数是通过赋值来传递的：
     + 参数的传递是通过自动将对象赋值给本地变量名来实现的。
     + 在函数内部的参数名的赋值不会影响调用者。
     + 改变函数的可变对象参数的值也许会对调用者有影响：
       + 不可变参数“通过值”进行传递。
       + 可变对象通过“指针”进行传递。
   + 参数匹配模型:
     + 定义：默认参数
     + 调用：关键字匹配


** 第 19 章 函数的高级话题
   + 递归可以遍历任意形状的结构。
   + 函数可以附加属性。
   + lambda 通常用来编写跳转表（行为的列表或字典）

** 第 20 章 迭代和解析

* 第五部分 模块
** 第 21 章 模块：宏伟蓝图
   + 模块定义的对象也会在执行时创建，就在 import 执行时。只在第一次导入模块时执行。再次导入只是提取内存中已加载的模块对象。
   + 模块文件的选择顺序。

** 第 22 章 模块代码编写基础

** 第 23 章 模块包

** 第 24 章 高级模块话题

* 第六部分
** 第 25 章 OOP 宏伟蓝图
   + 类是新的命名空间。每次调用一个类，就会产生一个有独立命名空间的新对象。每个类对象都能读取类的属性，并获得自己的命令空间来存储数据，这些数据对于每个对象都不同。
   + 类通过继承建立命名空间的层次结构。
   + 属性搜索：先搜索类对象，然后是该对象之上的所有类，从下到上，从左到右。
   + 类和实例是两种不同的对象类型，但在类树中它们几乎没有差别：每种类型的主要用途都是用作另一个类型的命名空间。
   + 在 OOP 中，实例就像是带有“数据”的记录，而类是处理这些记录的程序。
   + 类树中的所有对象都不过是命名空间对象。

** 第 26 章 类代码编写基础
   + 类和模块都是命名空间，它们的区别是类可以产生多个实例，支持继承，操作符重载。
   + 类对象来自语句，而实例来自调用。
   + 类通过对 self 参数进行赋值运算简历实例的所有属性。
   + 子类要明确调用超类的构造方法。


** 第 27 章 更多实例
   + 继承将属性传递到类，没有传递到实例。

** 第 28 章 类代码编写细节
   + 与 C++不同，Python 中 class 语句并不是声明式的。class 与 def 一样，创建了一个对象。该对象调用式产生了一个类实例。
   + 像 def 一样，class 语句也是真正的可执行代码。直到 Python 抵达并运行定义的 class 语句前，你的类都不存在。
   + 继承搜索只会在属性引用时发生，而不是在赋值运算时发生：对对象属性进行赋值总是修改该对象除此之外没有其他影响。
   + 在构造时，Python 会找出并且只调用一个__init__。
   + 类接口技术：super、inheritor、replacer、extender、provider。
   + 命名空间：
     + 无点号运算的变量名与作用域对应。
     + 点号的属性名使用的是对象的命名空间。
     + 有些作用域对对象的命名空间进行初始化（模块和类）。
     + python 中赋值变量名的场所决定了变量名所在的作用域或对象。


** 第 29 章 运算符重载
   + 运算符重载指示意味着在类方法中拦截内置的操作。
   + __getitem__用于索引和分片运算。
   + python 中所有的迭代环境都会先尝试__iter__方法，再尝试__getitem__。
   + 支持多个迭代器或者一个迭代器。
   + 运算符重载往往是多个层级的：类可以提供特定的方法，或者用作退而求其次选项的更通用的替代方案。
   + __getattr__用来响应对未定义属性名称和实例进行点号运行。
   + __setattr__要确定是通过对属性字典做索引来赋值任何实例属性。否则容易导致无穷递归循环。
   + __str__用户友好的显示可能只有当对象出现在一个打印操作顶层的时候才应用，嵌套到较大对象中的对象可能用其__repr__或默认方法打印。


** 第 30 章 类的设计
   + python 不能通过参数类型标记重载函数。Python 中的多态是基于对象接口的，而不是类型。
   + 变量名压缩只发生在类的内部，该功能主要是为了避免实例内的命名空间冲突，而不是限制变量名的读取（私有变量）。
   + 使用单个下划线类的内部名称。
   + 伪私有属性功能主要是为了缓和与实例属性存储方式有关的问题。
   + 类方法是绑定或无绑定。
   + python3.0 之后类中的属性搜索方法是广度优先。

** 第 31 章 类的高级主题

* 第七部分 异常和工具

** 第 32 章 异常基础
   + 异常是一种结构化的“超级 goto”。
   + 异常的用途：
     + 错误处理：当检测到错误时，python 会跳到 try 处理器，而程序在 try 之后重新继续执行。
     + 事件通知：调用函数捕捉异常，而不是判断整数返回结果。
     + 特殊情况处理：
     + 终止行为：
     + 非常规控制流程。
   + 注意 try/except/finally 中代码跳转流程。

** 第 33 章 异常编码细节
   + try 语句的运行方式：
     + 当 try 语句启动时，python 会标识当前的程序环境，这样一来，如果有异常发生时才能返回这里。
     + 如果 try 代码块语句执行时的确发生了异常，python 就跳回到 try，执行第一个符合引发异常的 except 子句下面的语句。当 except 代码块执行后，控制权就会到整个 try 语句后继续执行。
     + 如果没有符合的 except 语句，异常就向上传递。
     + 如果没有发生异常，就执行 else 语句。
   + 捕获一个名为 Exception 的异常几乎于一个可能过得 except 具有相同的效用，但是，忽略和系统退出相关的异常。
   + try/finally 执行完 finally 代码之后，接着会把异常向上传递到较高的 try 语句或顶层默认处理器。

** 第 34 章 异常对象

** 第 35 章 异常的设计

* 第八部分 高级话题
** 第 36 章 Unicode 和字节字符串
   + 字符在计算机内德存储方式要确保字符与原始字节之间可以使用一种编码相互转换，而编码就是把一个 unicode 字符转换为字节序列以及从一个字节序列提取字符串的规则。
   + utf-8 保持 ascii 字符串的紧凑，避免了字节排序问题，并且避免了可能对 C 库和网络连接引发问题的空（零）字节。
   + Python3.0 的 str 类型定义为一个不可改变的字符序列。bytes 类型定义为一个 8 位整数的不可变序列。bytearray 是 bytes 的一个变体，它是可变的并且在原处支持修改。
** 第 37 章 管理属性
** 第 38 章 装饰器
** 第 39 章 元类
* 第九部分 附录
