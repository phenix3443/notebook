<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-08-05 一 20:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>常见算法题目解析</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="liushangliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript" src="./script/org-info.js">

<script type="text/javascript" src="https://orgmode.org/org-info.js">
/**
 *
 * @source: https://orgmode.org/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in https://orgmode.org/org-info.js.
 *
 * Copyright (C) 2012-2019 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in https://orgmode.org/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "https://phenix3443.github.io/");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://phenix3443.github.io/"> HOME </a>
</div><div id="content">
<h1 class="title">常见算法题目解析</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org227c90a">1. Array（数组）</a>
<ul>
<li><a href="#orgd8f0949">1.1. 数组求和</a></li>
<li><a href="#orgfa40c3d">1.2. 求数组中出现次数超过一半的元素</a></li>
<li><a href="#org4170951">1.3. 求数组中元素的最短距离</a></li>
<li><a href="#org4f6e6a8">1.4. 求两个有序数组的共同元素</a></li>
<li><a href="#org06a1a5d">1.5. 求三个数组的共同元素</a></li>
<li><a href="#orge93c104">1.6. 找出出现奇数次的元素</a></li>
<li><a href="#org11960f0">1.7. 求有序数组中满足给定和的数对</a></li>
<li><a href="#org10fe913">1.8. 数组循环移位</a></li>
<li><a href="#orgf1369f2">1.9. 字符串逆序</a></li>
<li><a href="#org0426f11">1.10. 组合问题</a></li>
<li><a href="#orgc0bad67">1.11. 合并两个数组</a></li>
<li><a href="#org2645174">1.12. 重排问题</a></li>
<li><a href="#orgd066d3c">1.13. 找出绝对值最小的元素</a></li>
<li><a href="#orgd436327">1.14. 数组中前 K 大的数字</a></li>
<li><a href="#org802a4d5">1.15. 寻找出现次数最多的 K 个数</a></li>
<li><a href="#org20198ec">1.16. 查找不存在的数字或重复出现的数字</a></li>
<li><a href="#org149cc79">1.17. 数组元素随机重新排列</a></li>
<li><a href="#org5e705d1">1.18. 前缀和与前缀积及其应用</a>
<ul>
<li><a href="#org77246f5">1.18.1. 什么是前缀和、前缀积？前缀和、前缀积也称前缀和数组，前缀积数组。</a>
<ul>
<li><a href="#org554ce32">1.18.1.1. 题目 1：double a[n],b[n]，其中 <code>b[i]=a[0]*a[1]*…*a[i-1]*a[i+1]*…*a[n-1]</code> ，不能使用除法，不允许新开数组。</a></li>
<li><a href="#orga1757a0">1.18.1.2. 题目 2：求数组中连续一段和，绝对值最小？</a></li>
<li><a href="#orgbfaa47e">1.18.1.3. 题目 3：把一个数组从中间 p 位置分开，使得 <code>a[0]+…+a[p-1]</code> 与 <code>a[p]+a[p+1]+…+a[n-1]</code> 差值最小？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org511a7a8">2. Bit Manipulation</a>
<ul>
<li><a href="#org088ca2f">2.1. 位运算实现四则运算</a></li>
<li><a href="#org2686e90">2.2. 判断二进制中 0 或 1 的个数</a></li>
</ul>
</li>
<li><a href="#org1ec7f5c">3. Tree</a></li>
<li><a href="#org6850ed1">4. 什么是动态规划？动态规划的意义是什么？与递归、分治、贪婪的区别和联系</a>
<ul>
<li><a href="#orgcea73d2">4.1. 递归</a>
<ul>
<li><a href="#org0d6819d">4.1.1. 爬楼梯问题</a></li>
</ul>
</li>
<li><a href="#orge134926">4.2. Dynamic Programming（动态规划）</a>
<ul>
<li><a href="#orgee0a4b0">4.2.1. 最长递增子序列 (LIS)</a></li>
<li><a href="#orgbe72622">4.2.2. 最大连续子序列之和</a></li>
<li><a href="#org020a025">4.2.3. 数塔问题</a></li>
<li><a href="#org9848085">4.2.4. 背包问题</a></li>
<li><a href="#orgfcb8480">4.2.5. 最长公共子序列 (LCS)</a></li>
</ul>
</li>
<li><a href="#org6d8f412">4.3. Greedy（贪婪）</a></li>
</ul>
</li>
<li><a href="#orgf2196d1">5. Backtracking</a></li>
<li><a href="#org4c76746">6. Linked list</a>
<ul>
<li><a href="#orgcb3389c">6.1. 单链表反转</a></li>
<li><a href="#orgf4da559">6.2. 单链表判断是否有环</a></li>
<li><a href="#org6759150">6.3. 单链表判断是否相交</a></li>
</ul>
</li>
<li><a href="#org9a5cd9b">7. Math</a>
<ul>
<li>
<ul>
<li><a href="#orgf54d715">7.0.1. 大数加法</a></li>
<li><a href="#org9c61cdf">7.0.2. 高精度乘法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgba54f0f">8. String</a>
<ul>
<li><a href="#orge818504">8.1. 字符串逆序</a></li>
<li><a href="#org483d420">8.2. 单词逆序</a></li>
</ul>
</li>
<li><a href="#org89b825f">9. 大数据处理</a>
<ul>
<li><a href="#org21201b1">9.1. 中位数</a></li>
</ul>
</li>
<li><a href="#orgfc2e822">10. 快排 归并 二分查找</a></li>
<li><a href="#org92fdee9">11. 统计一些数字中出现次数最多的数字</a></li>
</ul>
</div>
</div>
<p>
内容包括 leetcode<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>、matrix67 的题目以及面试过程中遇到的一些题目。
主要是按照 leetcode 题型来分类：
</p>
<div id="outline-container-org227c90a" class="outline-2">
<h2 id="org227c90a"><span class="section-number-2">1</span> Array<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>（数组）</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgd8f0949" class="outline-3">
<h3 id="orgd8f0949"><span class="section-number-3">1.1</span> 数组求和</h3>
<div class="outline-text-3" id="text-1-1">
<p>
要求：只用一行代码
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #00d7af;">int</span> <span style="color: #ffd700;">sum</span>(<span style="color: #00d7af;">int</span>*<span style="color: #ff8700;">a</span>, <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">n</span>)
{
     <span style="color: #a1db00;">return</span> n ==0?0 : sum(a, n -1) + a[n -1];
}
</pre>
</div>
<p>
目的：了解循环和递归的关系。
</p>

<p>
延伸：
</p>
</div>
</div>

<div id="outline-container-orgfa40c3d" class="outline-3">
<h3 id="orgfa40c3d"><span class="section-number-3">1.2</span> 求数组中出现次数超过一半的元素</h3>
<div class="outline-text-3" id="text-1-2">
<p>
出自《编程之美》。思路如下：
最直接的解法：对数组进行排序，取 n/2 + 1 个元素即为所求，这种算法的复杂度最坏的情况下是 O(n^2), 平均情况下是 O(n*log2n)。
另一种方式：可以根据不同就抵消，相同就增一的计算器完成。设置一个当前值和当前值的计数器，初始化当前值为数组首元素，计数器值为 1，然后从第二个元素开始遍历整个数组，对于每个被遍历到的值 a[i]：
</p>
<ul class="org-ul">
<li>如果 a[i]==currentValue，则计数器值加 1。</li>
<li>如果 a[i] != currentValue， 则计数器值减 1，如果计数器值小于 0，则更新当前值为 a[i]，并将计数器值重置为 1。</li>
</ul>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #d18aff;">#include</span> <span style="color: #ff4ea3;">&lt;stdio.h&gt;</span>
<span style="color: #d18aff;">#include</span> <span style="color: #ff4ea3;">&lt;stdlib.h&gt;</span>

<span style="color: #00d7af;">int</span> <span style="color: #ffd700;">FindMoreValue</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">arr</span>[], <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">n</span>){
    <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span>;
    <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">curr_count</span> = 1;
    <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">curr_value</span> = arr[0];
    <span style="color: #a1db00;">for</span>(i = 1; i &lt; n; i++){
        <span style="color: #a1db00;">if</span>(arr[i] == curr_value){
            curr_count++;
        }<span style="color: #a1db00;">else</span>{
            curr_count--;
            <span style="color: #a1db00;">if</span>(curr_count &lt; 0){
                curr_value = arr[i];
                curr_count = 1;
            }
        }
    }
    <span style="color: #a1db00;">if</span>(curr_count &gt; 0){
        <span style="color: #a1db00;">return</span> curr_value;
    }<span style="color: #a1db00;">else</span>{
        <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#19981;&#23384;&#22312;&#20986;&#29616;&#27425;&#25968;&#36229;&#36807;&#19968;&#21322;&#30340;&#20803;&#32032;</span>
        <span style="color: #a1db00;">return</span> -1;
    }
}
</pre>
</div>
<p>
延伸：如果是出现次数超过 1/m 的元素呢？
</p>
</div>
</div>
<div id="outline-container-org4170951" class="outline-3">
<h3 id="org4170951"><span class="section-number-3">1.3</span> 求数组中元素的最短距离</h3>
<div class="outline-text-3" id="text-1-3">
<p>
先对数组排序，然后遍历一次即可
</p>
</div>
</div>
<div id="outline-container-org4f6e6a8" class="outline-3">
<h3 id="org4f6e6a8"><span class="section-number-3">1.4</span> 求两个有序数组的共同元素</h3>
</div>
<div id="outline-container-org06a1a5d" class="outline-3">
<h3 id="org06a1a5d"><span class="section-number-3">1.5</span> 求三个数组的共同元素</h3>
</div>
<div id="outline-container-orge93c104" class="outline-3">
<h3 id="orge93c104"><span class="section-number-3">1.6</span> 找出出现奇数次的元素</h3>
<div class="outline-text-3" id="text-1-6">
<p>
所有元素求异或，结果就是所找的元素。
</p>
</div>
</div>
<div id="outline-container-org11960f0" class="outline-3">
<h3 id="org11960f0"><span class="section-number-3">1.7</span> 求有序数组中满足给定和的数对</h3>
</div>
<div id="outline-container-org10fe913" class="outline-3">
<h3 id="org10fe913"><span class="section-number-3">1.8</span> 数组循环移位</h3>
<div class="outline-text-3" id="text-1-8">
<p>
《编程之美》
</p>
</div>
</div>
<div id="outline-container-orgf1369f2" class="outline-3">
<h3 id="orgf1369f2"><span class="section-number-3">1.9</span> 字符串逆序</h3>
<div class="outline-text-3" id="text-1-9">
<p>
将一个含有 n 个元素的数组向右循环移动 k 位，要求时间复杂度是 O(n)，且只能使用两个额外的变量。
</p>

<p>
思路：比如数组 1 2 3 4 循环右移 1 位 将变成 4 1 2 3， 观察可知 1 2 3 的顺序在移位前后没有改变，只是和 4 的位置交换了一下，所以等同于 1 2 3 4 先划分为两部分：1 2 3 | 4，然后将 1 2 3 逆序，再将 4 逆序 得到 3 2 1 4，最后整体逆序 得到 4 1 2 3
</p>
</div>
</div>

<div id="outline-container-org0426f11" class="outline-3">
<h3 id="org0426f11"><span class="section-number-3">1.10</span> 组合问题</h3>
<div class="outline-text-3" id="text-1-10">
<p>
给定一个含有 n 个元素的整型数组 a，从中任取 m 个元素，求所有组合。比如下面的例子
</p>
<pre class="example">
a = 1, 2, 3, 4, 5
m = 3
</pre>
<p>
输出
</p>
<pre class="example">
1 2 3, 1 2 4, 1 2 5, 1 3 4, 1 3 5, 1 4 5，2 3 4, 2 3 5, 2 4 5，3 4 5
</pre>

<p>
分析：典型的排列组合问题，首选回溯法，为了简化问题，我们将 a 中 n 个元素值分别设置为 1-n
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">n &#36873; m &#30340;&#25152;&#26377;&#32452;&#21512;</span>
<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">buffer</span>[100] ;

<span style="color: #00d7af;">void</span> <span style="color: #ffd700;">PrintArray</span>(<span style="color: #00d7af;">int</span> *<span style="color: #ff8700;">a</span>, <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">n</span>)
{
    <span style="color: #a1db00;">for</span> (<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; n; ++i)
        cout &lt;&lt; a[i] &lt;&lt; <span style="color: #ff4ea3;">""</span>;
    cout &lt;&lt; endl ;
}

<span style="color: #00d7af;">bool</span> <span style="color: #ffd700;">IsValid</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">lastIndex</span>, <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">value</span>)
{
    <span style="color: #a1db00;">for</span> (<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; lastIndex; i++)
    {
        <span style="color: #a1db00;">if</span> (buffer[i] &gt;= value)
            <span style="color: #a1db00;">return</span> <span style="color: #5fafd7;">false</span>;
    }
    <span style="color: #a1db00;">return</span> <span style="color: #5fafd7;">true</span>;
}

<span style="color: #00d7af;">void</span> <span style="color: #ffd700;">Select</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">t</span>, <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">n</span>, <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">m</span>)
{
    <span style="color: #a1db00;">if</span> (t == m)
        PrintArray(buffer, m);
    <span style="color: #a1db00;">else</span>
    {
        <span style="color: #a1db00;">for</span> (<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = 1; i &lt;= n; i++)
        {
            buffer[t] = i;
            <span style="color: #a1db00;">if</span> (IsValid(t, i))
                Select(t + 1, n, m);
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc0bad67" class="outline-3">
<h3 id="orgc0bad67"><span class="section-number-3">1.11</span> 合并两个数组</h3>
</div>
<div id="outline-container-org2645174" class="outline-3">
<h3 id="org2645174"><span class="section-number-3">1.12</span> 重排问题</h3>
</div>
<div id="outline-container-orgd066d3c" class="outline-3">
<h3 id="orgd066d3c"><span class="section-number-3">1.13</span> 找出绝对值最小的元素</h3>
</div>
<div id="outline-container-orgd436327" class="outline-3">
<h3 id="orgd436327"><span class="section-number-3">1.14</span> 数组中前 K 大的数字</h3>
<div class="outline-text-3" id="text-1-14">
<p>
使用堆排序，或者 STL 的部分排序。
</p>
</div>
</div>
<div id="outline-container-org802a4d5" class="outline-3">
<h3 id="org802a4d5"><span class="section-number-3">1.15</span> 寻找出现次数最多的 K 个数</h3>
<div class="outline-text-3" id="text-1-15">
<p>
延伸：服务器内存 1G，有一个 2G 的文件，里面每行存着一个 QQ 号（5-10 位数），怎么最快找出出现过最多次的 QQ 号。
</p>

<p>
解法：
</p>

<p>
1.将不同的 qq 号码 hash 到 1000 小文件中，然后对单个小文件中的数据进行 hash 统计出现次数，找出该文件中出现次数最多的 qq 号，然后 1000 个 qq 进行排序，找出出现次数最多的。
</p>

<p>
2.使用位运算计数，使用 m 个 bit 表示 qq 号码，n 个 bit 表示出现的次数，比较适合没有太大极端的情况。
</p>
</div>
</div>
<div id="outline-container-org20198ec" class="outline-3">
<h3 id="org20198ec"><span class="section-number-3">1.16</span> 查找不存在的数字或重复出现的数字</h3>
<div class="outline-text-3" id="text-1-16">
<p>
a[n]数组中有 n-1 个取值范围在 0 到 n-1 的数，并且不重复，剩余那个数组项为-1，求不存在的那个数是多少？
解法：用 0 到 n-1 的累计和减去数组的总和，差值就是不存的那个数字。
</p>

<p>
延伸：
</p>
<ul class="org-ul">
<li>如果有两个不存在的数呢？</li>
</ul>


<ul class="org-ul">
<li>如果有 m 个不存在的数呢？</li>
</ul>

<p>
解法：将值为 i 的数字放在 a[i] 位置上，最后值为-1 的位置就是不存在的项。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #d18aff;">#include</span> <span style="color: #ff4ea3;">&lt;iostream&gt;</span>
<span style="color: #d18aff;">#include</span> <span style="color: #ff4ea3;">&lt;algorithm&gt;</span>

<span style="color: #00d7af;">void</span> <span style="color: #ffd700;">mNoExistInN</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">a</span>[], <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">n</span>) {
    <span style="color: #a1db00;">for</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span>=0; i&lt;n-1; ++i) {
        <span style="color: #a1db00;">while</span>(a[i]!=i) {
            <span style="color: #a1db00;">if</span>(a[i] == -1) {
                <span style="color: #5fafd7;">std</span>::cout &lt;&lt; i &lt;&lt; <span style="color: #ff4ea3;">" not exists"</span> &lt;&lt; <span style="color: #5fafd7;">std</span>::endl;
                <span style="color: #a1db00;">break</span>;
            }
            <span style="color: #a1db00;">else</span> {
                swap(&amp;a[i],&amp;a[a[i]]);
            }
        }
    }
}
</pre>
</div>
<ul class="org-ul">
<li>一个文件中有 40 亿个整数，每个整数为四个字节，内存为 1GB，写出一个算法：求出这个文件里的整数里不包含的一个整数。</li>
</ul>

<p>
解法：使用一个 bit 表示出现。
</p>
<ol class="org-ol">
<li>腾讯服务器每秒有 2w 个 QQ 号同时上线，找出 5min 内重新登入的 qq 号并打印出来。</li>
</ol>
</div>
</div>


<div id="outline-container-org149cc79" class="outline-3">
<h3 id="org149cc79"><span class="section-number-3">1.17</span> 数组元素随机重新排列</h3>
</div>
<div id="outline-container-org5e705d1" class="outline-3">
<h3 id="org5e705d1"><span class="section-number-3">1.18</span> 前缀和与前缀积及其应用</h3>
<div class="outline-text-3" id="text-1-18">
</div>
<div id="outline-container-org77246f5" class="outline-4">
<h4 id="org77246f5"><span class="section-number-4">1.18.1</span> 什么是前缀和、前缀积？前缀和、前缀积也称前缀和数组，前缀积数组。</h4>
<div class="outline-text-4" id="text-1-18-1">
<p>
给一数组 A
</p>
<ul class="org-ul">
<li>前缀和：新建一数组 B，数组中每一项 B[i]保存 A 中[0…i]的和；</li>
<li>后缀和：新建一数组 B，数组中每一项 B[i]保存 A 中[i…n-1]的和；</li>
<li>前缀积：新建一数组 B，数组中每一项 B[i]保存 A 中[0…i]的积；</li>
<li>后缀积：新建一数组 B，数组中每一项 B[i]保存 A 中[i…n-1]的积；</li>
</ul>
</div>

<div id="outline-container-org554ce32" class="outline-5">
<h5 id="org554ce32"><span class="section-number-5">1.18.1.1</span> 题目 1：double a[n],b[n]，其中 <code>b[i]=a[0]*a[1]*…*a[i-1]*a[i+1]*…*a[n-1]</code> ，不能使用除法，不允许新开数组。</h5>
<div class="outline-text-5" id="text-1-18-1-1">
<p>
思路：观察表达式可以发现
</p>
<pre class="example">
b[i]=P[i]*S[i]
</pre>
<p>
其中 <code>P[i]=a[0]*a[1]*…*a[i-1]</code> ， <code>S[i]=a[i+1]*…*a[n-1]</code> 。进一步观察 b[i]和 b[i-1]关系：
</p>
<pre class="example">
P[i]=P[i-1]*a[i-1]
S[i]=S[i-1]/a[i]
</pre>
<p>
考虑不能使用除法,所以上面第二个式子变换为：
</p>
<pre class="example">
S[i-1]=a[i]*S[i]
</pre>
<p>
可以发现如果求后缀从后往前遍历比较方便。
</p>

<p>
所以思路也就清除，先遍历 a[i]求前缀积，结果保存 b[i]中，然后遍历一次求后缀积，两者相乘。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">PreSuffAcc</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">a</span>[], <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">b</span>[], <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">len</span>) {
    <span style="color: #a1db00;">for</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span>=0; i&lt;len; ++i) {
        b[i] = (i==0) ? 1 : a[i-1]*b[i-1]; <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">p</span>
    }
    <span style="color: #a1db00;">for</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span>=n-1,<span style="color: #ff8700;">j</span>=1; i&gt;=0&#65307;--i) {
        j = (i==n-1)?1:j*a[i+1];<span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">s</span>
        b[i] *= j;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1757a0" class="outline-5">
<h5 id="orga1757a0"><span class="section-number-5">1.18.1.2</span> 题目 2：求数组中连续一段和，绝对值最小？</h5>
<div class="outline-text-5" id="text-1-18-1-2">
<p>
思路：前缀和的性质： <code>a[i]+a[i+1]+…+a[j]=sum[j]-sum[i-1]</code> 前缀和排序，取最小
</p>
</div>
</div>

<div id="outline-container-orgbfaa47e" class="outline-5">
<h5 id="orgbfaa47e"><span class="section-number-5">1.18.1.3</span> 题目 3：把一个数组从中间 p 位置分开，使得 <code>a[0]+…+a[p-1]</code> 与 <code>a[p]+a[p+1]+…+a[n-1]</code> 差值最小？</h5>
<div class="outline-text-5" id="text-1-18-1-3">
<p>
思路：前缀和-（总和-前缀和）=2*前缀和-总和，是该公式最小；
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org511a7a8" class="outline-2">
<h2 id="org511a7a8"><span class="section-number-2">2</span> Bit Manipulation</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org088ca2f" class="outline-3">
<h3 id="org088ca2f"><span class="section-number-3">2.1</span> 位运算实现四则运算</h3>
</div>
<div id="outline-container-org2686e90" class="outline-3">
<h3 id="org2686e90"><span class="section-number-3">2.2</span> 判断二进制中 0 或 1 的个数</h3>
</div>
</div>
<div id="outline-container-org1ec7f5c" class="outline-2">
<h2 id="org1ec7f5c"><span class="section-number-2">3</span> Tree</h2>
</div>
<div id="outline-container-org6850ed1" class="outline-2">
<h2 id="org6850ed1"><span class="section-number-2">4</span> 什么是动态规划？动态规划的意义是什么？与递归、分治、贪婪的区别和联系<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup></h2>
<div class="outline-text-2" id="text-4">
<p>
下面是知乎上王勐关于这个问题的回答，讲解的很透彻（<a href="https://www.zhihu.com/question/23995189/answer/35429905">链接</a>） ：
</p>

<p>
动态规划的本质不在于是递推或是递归，也不需要纠结是不是内存换时间。理解动态规划并不需要数学公式介入，只是完全解释清楚需要点篇幅…
</p>

<p>
首先需要明白哪些问题不是动态规划可以解决的，才能明白为神马需要动态规划。不过好处是顺便也就搞明白了递推贪心搜索和动规之间有什么关系，以及帮助那些总是把动规当成搜索解的同学建立动规的思路。当然，熟悉了之后可以直接根据问题的描述得到思路，如果有需要的话再补充吧。
</p>

<p>
动态规划是对于某一类问题的解决方法！！重点在于如何鉴定“某一类问题”是动态规划可解的，而不是纠结解决方法是递归还是递推！怎么鉴定 dp 可解的一类问题需要从计算机是怎么工作的说起…
</p>

<p>
计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU 只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑它们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）。当你企图使用计算机解决一个问题时， <b>其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）</b> 。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！
</p>

<p>
太抽象了还是举个例子吧：
</p>

<p>
比如说我想计算第 100 个斐波那契数，每一个斐波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。
</p>

<p>
上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。
</p>

<p>
斐波那契那个例子过于简单，以至于让人忽视了 <b>阶段</b> 的概念， <b>所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合</b> （注意是集合） 。
</p>

<p>
斐波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。想象另外一个问题情景，假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了 n 步可能处于的位置称为一个状态，走了这 n 步所有可能到达的位置的集合就是这个阶段下所有可能的状态。
</p>

<p>
现在问题来了， <b>有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法</b> ，下面就分情况来说明一下：
</p>

<p>
假如问题有 n 个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同， <b>一个阶段的一个状态可以得到下个阶段的所有状态中的几个</b> （注意不是能够得到下个阶段的所有 状态）。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。
</p>

<p>
好消息是，有时候我们并不需要真的计算所有状态，比如这样一个弱智的棋盘问题：从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个弱智的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走 n 步可以走到很多位置一样。但是同样 n 步中，有哪些位置可以让我们在第 n+1 步中走的最远呢？没错，正是第 n 步中走的最远的位置。换成一句熟悉话叫做 “下一步最优是从当前最优得到的”。所以 <b>为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心</b> 。如果只看最优状态之间的计算过程是不是和斐波那契数列的计算很像？所以计算的方法是递推。
</p>

<p>
既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。
</p>

<p>
如果一个阶段的最优无法用前一个阶段的最优得到呢？
</p>

<p>
什么你说只需要之前两个阶段就可以得到当前最优？那跟只用之前一个阶段并没有本质区别。
</p>

<p>
最麻烦的情况在于你 <b>需要之前所有的情况</b> 才行。
</p>

<p>
再来一个迷宫的例子：在计算从起点到终点的最短路线时，你不能只保存当前阶段的状态，因为题目要求你最短，所以你 <b>必须知道之前走过的所有位置</b> 。因为即便你当前在的位置不变， <b>之前的路线不同会影响你的之后走的路线</b> 。这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！
</p>

<p>
每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。哦哦，刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做有后效性。
</p>

<p>
刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？
</p>

<p>
契机就在于后效性。
</p>

<p>
有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上升子序列的例子来说明为什么它不必需要暴力搜索，进而引出动态规划的思路。假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足 “上升” 的性质，这里第 i 个阶段就是去思考是否要选择第 i 个数，第 i 个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候， <b>只需要和之前选定的一个数字比较就行了</b> ！这是和之前迷宫问题的本质不同！这就可以纵容我们 <b>不需要记录之前所有的状态</b> 啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的 LIS 长度就好！因此第 i 个阶段的最优解只是由前 i-1 个阶段的最优解得到的，然后就得到了 DP 方程。
</p>
<pre class="example">
LIS(i) = max{LIS(j)+1} j&lt;i and a[j]&lt;a[i]
</pre>
<p>
所以 <b>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！</b> :
</p>
<ul class="org-ul">
<li>每个阶段只有一个状态 -&gt; 递推；</li>
<li>每个阶段的最优状态都是由上一个阶段的最优状态得到的 -&gt; 贪心；</li>
<li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的 -&gt; 搜索；</li>
<li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的 -&gt; 动态规划。</li>
</ul>

<p>
<b>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；而不管之前这个状态是如何得到的这个性质叫做无后效性。</b> 另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS 问题确实如此，转移时只用到了每个阶段 “选” 的状态。但实际上有的问题往往 <b>需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。</b> 比如背包问题就需要对前 i 个包（阶段）容量为 j 时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。
</p>
</div>
<div id="outline-container-orgcea73d2" class="outline-3">
<h3 id="orgcea73d2"><span class="section-number-3">4.1</span> 递归</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org0d6819d" class="outline-4">
<h4 id="org0d6819d"><span class="section-number-4">4.1.1</span> 爬楼梯问题</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
有 n 层的台阶，一开始你站在第 0 层，每次最多可以爬 m 层，请问爬到第 n 层有多少种不同的方法？
</p>

<p>
解法：S(k)表示第 k 层的爬法，那么最后一步他爬的楼层可能是 1 到 m 的任意值，所以 S(k)=S(k-1)+&#x2026;.+S(k-m)，还是递归问题，并不是动态规划。
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">clim_stair</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">m</span>, <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">k</span>) {
    <span style="color: #a1db00;">static</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">a</span>[k];
    <span style="color: #a1db00;">if</span>(a[k]==0) {
        <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">cal a[k]</span>
        <span style="color: #a1db00;">if</span>(k==0) {
            a[k] = 1;
        }
        <span style="color: #a1db00;">else</span> {
            <span style="color: #a1db00;">for</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span>=k-1; (i&gt;=k-m)&amp;&amp;(i&gt;=0); --i) {
                a[k] += clim_stair(i);
            }
        }
    }
    <span style="color: #a1db00;">return</span> a[k];
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge134926" class="outline-3">
<h3 id="orge134926"><span class="section-number-3">4.2</span> Dynamic Programming（动态规划）</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgee0a4b0" class="outline-4">
<h4 id="orgee0a4b0"><span class="section-number-4">4.2.1</span> 最长递增子序列 (LIS)</h4>
</div>
<div id="outline-container-orgbe72622" class="outline-4">
<h4 id="orgbe72622"><span class="section-number-4">4.2.2</span> 最大连续子序列之和</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
给定 K 个整数的序列 {N1, N2, &#x2026;, NK}，其任意连续子序列可表示为 {Ni, Ni+1, &#x2026;, Nj}，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序中元素和最大的一个， 例如给定序列 {-2, 11, -4, 13, -5, -2}，其最大连续子序列为 {11, -4, 13}，最大和为 20。
</p>

<p>
状态转移方程：sum[i]=max(sum[i-1]+a[i],a[i])
</p>
</div>
</div>
<div id="outline-container-org020a025" class="outline-4">
<h4 id="org020a025"><span class="section-number-4">4.2.3</span> 数塔问题</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
数塔问题 ：要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？
</p>
</div>
</div>
<div id="outline-container-org9848085" class="outline-4">
<h4 id="org9848085"><span class="section-number-4">4.2.4</span> 背包问题</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
有 n 个重量和价值分别为 vector&lt;int&gt; weight, vector&lt;int&gt; value 的物品；背包最大负重为 W，求能用背包装下的物品的最大价值？
</p>
</div>
</div>
<div id="outline-container-orgfcb8480" class="outline-4">
<h4 id="orgfcb8480"><span class="section-number-4">4.2.5</span> 最长公共子序列 (LCS)</h4>
<div class="outline-text-4" id="text-4-2-5">
<p>
一个序列 S，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。
</p>
</div>
</div>
</div>
<div id="outline-container-org6d8f412" class="outline-3">
<h3 id="org6d8f412"><span class="section-number-3">4.3</span> Greedy（贪婪）</h3>
</div>
</div>

<div id="outline-container-orgf2196d1" class="outline-2">
<h2 id="orgf2196d1"><span class="section-number-2">5</span> Backtracking</h2>
</div>
<div id="outline-container-org4c76746" class="outline-2">
<h2 id="org4c76746"><span class="section-number-2">6</span> Linked list</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgcb3389c" class="outline-3">
<h3 id="orgcb3389c"><span class="section-number-3">6.1</span> 单链表反转</h3>
</div>
<div id="outline-container-orgf4da559" class="outline-3">
<h3 id="orgf4da559"><span class="section-number-3">6.2</span> 单链表判断是否有环</h3>
</div>
<div id="outline-container-org6759150" class="outline-3">
<h3 id="org6759150"><span class="section-number-3">6.3</span> 单链表判断是否相交</h3>
</div>
</div>
<div id="outline-container-org9a5cd9b" class="outline-2">
<h2 id="org9a5cd9b"><span class="section-number-2">7</span> Math</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgf54d715" class="outline-4">
<h4 id="orgf54d715"><span class="section-number-4">7.0.1</span> 大数加法</h4>
<div class="outline-text-4" id="text-7-0-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;iostream&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;vector&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;string&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;map&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;memory&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;algorithm&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;cassert&gt;</span>
<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;functional&gt;</span>

<span style="color: #d18aff;">        #include</span> <span style="color: #ff4ea3;">&lt;gtest\gtest.h&gt;</span>

        <span style="color: #a1db00;">namespace</span> <span style="color: #5fafd7;">phenix3443</span> {
            <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#24314;&#31435;&#36827;&#21046;&#23545;&#24212;&#30340;&#21704;&#24076;&#34920;</span>
            <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">shared_ptr</span>&lt;<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">char</span>, <span style="color: #00d7af;">short</span>&gt;&gt; <span style="color: #ffd700;">Map_10</span> () {
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">r_map</span> = <span style="color: #5fafd7;">std</span>::make_shared&lt;<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">char</span>, <span style="color: #00d7af;">short</span>&gt;&gt; ();

                <span style="color: #a1db00;">for</span> ( <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; 10; ++i ) {
                    (*r_map)[<span style="color: #ff4ea3;">'0'</span> + i] = i;
                }
                <span style="color: #a1db00;">return</span> r_map;
            }
            <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">shared_ptr</span>&lt;<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">char</span>, <span style="color: #00d7af;">short</span>&gt;&gt; <span style="color: #ffd700;">Map_16</span> () {
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">r_map</span> = <span style="color: #5fafd7;">std</span>::make_shared&lt;<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">char</span>, <span style="color: #00d7af;">short</span>&gt;&gt; ();

                <span style="color: #a1db00;">for</span> ( <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; 10; ++i ) {
                    (*r_map)[<span style="color: #ff4ea3;">'0'</span> + i] = i;
                }
                <span style="color: #a1db00;">for</span> ( <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = 10; i &lt; 16; ++i ) {
                    (*r_map)[<span style="color: #ff4ea3;">'A'</span> + i - 10] = i;
                }
                <span style="color: #a1db00;">return</span> r_map;
            }
            <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">short</span>, <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">function</span>&lt;<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">shared_ptr</span>&lt;<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">char</span>, <span style="color: #00d7af;">short</span>&gt;&gt; ()&gt;&gt; <span style="color: #ff8700;">build_randix_map</span> = {
                { 10,Map_10 },
                { 16,Map_16 },
            };
            <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#23558; std::string &#34920;&#31034;&#30340;&#22823;&#25968;&#23384;&#25918;&#22312; std::vector&lt;short&gt;&#20013;</span>
            <span style="color: #a1db00;">inline</span> <span style="color: #00d7af;">void</span> <span style="color: #ffd700;">str_to_vc</span> (<span style="color: #a1db00;">const</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span>&amp; <span style="color: #ff8700;">str</span>, <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">short</span>&gt;&amp; <span style="color: #ff8700;">vs</span>, <span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">base</span> = 10) {
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">r_map</span> = build_randix_map[base] ();

                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">function</span>&lt;<span style="color: #00d7af;">bool</span> (<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span>&amp;)&gt; <span style="color: #ff8700;">f</span> = [&amp;](<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span>&amp; <span style="color: #ff8700;">c</span>) {<span style="color: #a1db00;">return</span> (*r_map).count (c) != 0; };
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">first_dig</span> = find_if (str.begin (), str.end (), f);
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">last_dig</span> = find_if_not (first_dig, str.end (), f);
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">sign_at</span> = find (str.begin (), first_dig, <span style="color: #ff4ea3;">'-'</span>);
                <span style="color: #00d7af;">short</span> <span style="color: #ff8700;">sign</span> = (sign_at != first_dig) ? -1 : 1;

                for_each (first_dig, last_dig, [&amp;](<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span>&amp; <span style="color: #ff8700;">e</span>) {vs.push_back (sign*((*r_map)[e])); });
            }
            <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#23558; std::vector&lt;short&gt;&#20013;&#23384;&#25918;&#30340;&#22823;&#25968;&#25918;&#22238; std::string &#20013;</span>
            <span style="color: #a1db00;">inline</span> <span style="color: #00d7af;">void</span> <span style="color: #ffd700;">vc_to_str</span> (<span style="color: #a1db00;">const</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">short</span>&gt;&amp; <span style="color: #ff8700;">vs</span>, <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span>&amp; <span style="color: #ff8700;">str</span>, <span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">base</span> = 10) {
                <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">r_map</span> = build_randix_map[base] ();
                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">map</span>&lt;<span style="color: #00d7af;">short</span>, <span style="color: #00d7af;">char</span>&gt; <span style="color: #ff8700;">tmp_map</span>;
                <span style="color: #a1db00;">for</span> ( <span style="color: #a1db00;">auto</span>&amp; <span style="color: #ff8700;">e</span> : *r_map )
                    tmp_map.insert ({ e.second,e.first });
                for_each (vs.begin (), vs.end (), [&amp;](<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">short</span>&amp; <span style="color: #ff8700;">e</span>) {str.push_back (tmp_map[(e + base) % base]); });
                <span style="color: #a1db00;">if</span> ( vs[0] &lt; 0 ) str.insert (str.begin (), <span style="color: #ff4ea3;">'-'</span>);
            }

            <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#22823;&#25972;&#25968;&#21152;&#27861;</span>
            <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#32771;&#34385;&#65306;    1.&#26377;&#25928;&#36755;&#20837;&#65292;&#21253;&#21547;&#27491;&#36127;&#21495;&#65292;&#23383;&#31526;&#20018;&#20013;&#38750;&#25968;&#23383;&#23383;&#31526;,&#23383;&#31526;&#20018;&#24320;&#22987;&#30340;&#36830;&#32493;&#31354;&#26684;&#65292;</span>
            <span style="color: #6c6c6c; font-style: italic;">//      </span><span style="color: #6c6c6c; font-style: italic;">2.&#23384;&#25918;&#30340;&#25968;&#25454;&#32467;&#26500; std::vector &#19982; std::string</span>
            <span style="color: #6c6c6c; font-style: italic;">//      </span><span style="color: #6c6c6c; font-style: italic;">3.&#22914;&#20309;&#22788;&#29702;&#36827;&#20301;</span>
            <span style="color: #6c6c6c; font-style: italic;">//      </span><span style="color: #6c6c6c; font-style: italic;">4.&#38543;&#24847;&#36755;&#20837;&#22823;&#25968;&#23383;&#30340;&#38271;&#24230;&#22823;&#23567;</span>
            <span style="color: #6c6c6c; font-style: italic;">//      </span><span style="color: #6c6c6c; font-style: italic;">5.&#36827;&#21046;</span>

            <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#30693;&#35782;&#28857;&#65306;1.&#23383;&#31526;&#19982;&#25968;&#23383;&#20043;&#38388;&#30340;&#36716;&#25442;</span>
            <span style="color: #6c6c6c; font-style: italic;">//       </span><span style="color: #6c6c6c; font-style: italic;">2.const &#22312;&#21442;&#25968;&#21015;&#34920;&#22788;&#30340;&#20351;&#29992;</span>
            <span style="color: #6c6c6c; font-style: italic;">//       </span><span style="color: #6c6c6c; font-style: italic;">3.STL &#31639;&#27861;&#24211;&#20351;&#29992; find &#31995;&#21015; for_each</span>
            <span style="color: #6c6c6c; font-style: italic;">//       </span><span style="color: #6c6c6c; font-style: italic;">4.lamda &#20989;&#25968;&#30340;&#20351;&#29992;&#65292;&#20540;&#25429;&#33719;&#19982;&#24341;&#29992;&#25429;&#33719;</span>
            <span style="color: #6c6c6c; font-style: italic;">//       </span><span style="color: #6c6c6c; font-style: italic;">5.&#36127;&#25968;&#21462;&#27169;&#36816;&#31639;</span>

            <span style="color: #00d7af;">int</span> <span style="color: #ffd700;">BigSum</span> (<span style="color: #a1db00;">const</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span>&amp; <span style="color: #ff8700;">num1</span>, <span style="color: #a1db00;">const</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span>&amp; <span style="color: #ff8700;">num2</span>, <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span>&amp; <span style="color: #ff8700;">sum</span>, <span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">base</span> = 10) {
                assert (<span style="color: #ff4b4b;">!</span>num1.empty () &amp;&amp; <span style="color: #ff4b4b;">!</span>num2.empty () &amp;&amp; sum.empty ());
                <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#23558; std::string &#27599;&#19968;&#20301;&#36716;&#25442;&#20026; voctor&lt;short&gt;&#23545;&#24212;&#30340;&#25968;&#23383;</span>
                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">short</span>&gt; <span style="color: #ff8700;">vbig</span>, <span style="color: #ff8700;">vsmall</span>;

                str_to_vc (num1, vbig);
                str_to_vc (num2, vsmall);

                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#20445;&#35777; vbig &#20445;&#23384;&#20102;&#36739;&#22823;&#30340;&#25968;</span>
                <span style="color: #a1db00;">if</span> ( vbig.size () &lt; vsmall.size () ) swap (vbig, vsmall);
                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">vbig vsmall &#25353;&#20301;&#32047;&#21152;&#65292;&#19981;&#32771;&#34385;&#36827;&#20301;</span>
                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">short</span>&gt; <span style="color: #ff8700;">vsum</span> (vbig.size (), 0);
                <span style="color: #a1db00;">for</span> ( <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = vbig.size () - 1, <span style="color: #ff8700;">j</span> = vsmall.size () - 1; i &gt;= 0; --i ) {
                    vsum[i] = vbig[i] + ((j &gt;= 0) ? vsmall[j--] : 0);
                }
                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#22788;&#29702;&#36827;&#20301;</span>
                <span style="color: #a1db00;">for</span> ( <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">i</span> = vsum.size () - 1; i &gt;= 0; --i ) {
                    <span style="color: #a1db00;">if</span> ( vsum[i] &gt; base ) {
                        vsum[i] -= base;
                        <span style="color: #a1db00;">if</span> ( i &gt; 0 )
                            ++vsum[i - 1];
                        <span style="color: #a1db00;">else</span>
                            vsum.insert (vsum.begin (), 1);
                    }
                }
                <span style="color: #6c6c6c; font-style: italic;">//</span><span style="color: #6c6c6c; font-style: italic;">&#31532;&#19968;&#27493;&#30340;&#36870;&#36716;&#25442;</span>
                vc_to_str (vsum, sum);
                <span style="color: #a1db00;">return</span> 0;
            }

            <span style="color: #ffd700;">TEST</span>(TestBigSum,mul){
                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">a</span> = <span style="color: #ff4ea3;">"-2222"</span>;
                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">b</span> = <span style="color: #ff4ea3;">"1111"</span>;
                <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">sum</span>;
                BigSum (b, a, sum);
                EXPECT_STREQ (<span style="color: #ff4ea3;">"-9999"</span>, sum.c_str ());
            }
        }
</pre>
</div>
</div>
</div>
<div id="outline-container-org9c61cdf" class="outline-4">
<h4 id="org9c61cdf"><span class="section-number-4">7.0.2</span> 高精度乘法</h4>
<div class="outline-text-4" id="text-7-0-2">
<p>
两个数相乘，小数点后位数没有限制，请写一个高精度算法
</p>
</div>
</div>
</div>
<div id="outline-container-orgba54f0f" class="outline-2">
<h2 id="orgba54f0f"><span class="section-number-2">8</span> String</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orge818504" class="outline-3">
<h3 id="orge818504"><span class="section-number-3">8.1</span> 字符串逆序</h3>
</div>
<div id="outline-container-org483d420" class="outline-3">
<h3 id="org483d420"><span class="section-number-3">8.2</span> 单词逆序</h3>
</div>
</div>
<div id="outline-container-org89b825f" class="outline-2">
<h2 id="org89b825f"><span class="section-number-2">9</span> 大数据处理</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org21201b1" class="outline-3">
<h3 id="org21201b1"><span class="section-number-3">9.1</span> 中位数</h3>
<div class="outline-text-3" id="text-9-1">
<p>
在一个文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。只写出思路即可。
</p>
</div>
</div>
</div>

<div id="outline-container-orgfc2e822" class="outline-2">
<h2 id="orgfc2e822"><span class="section-number-2">10</span> 快排 归并 二分查找</h2>
</div>

<div id="outline-container-org92fdee9" class="outline-2">
<h2 id="org92fdee9"><span class="section-number-2">11</span> 统计一些数字中出现次数最多的数字</h2>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://leetcode.com/">leetcode 官网</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.cnblogs.com/graphics/archive/2010/08/24/1761620.html">关于数组的几道面试题</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.zhihu.com/question/23995189">这个问题在知乎上面的回答，排名前 2 的回答讲的很好</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: liushangliang</p>
<p class="email">Email: <a href="mailto:phenix3443+github@gmail.com">phenix3443+github@gmail.com</a></p>
<p class="date">Created: 2019-08-05 一 20:30</p>
<p class="validation"></p>
</div>
</body>
</html>
